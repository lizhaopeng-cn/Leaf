package com.lzp.book.been;

import java.util.List;

/**
 * Created by lzp48947 on 2017/12/25.
 */

public class BookBeen {

    /**
     * count : 20
     * start : 0
     * total : 1082
     * books : [{"rating":{"max":10,"numRaters":421,"average":"8.4","min":0},"subtitle":"Android","author":["郭霖"],"pubdate":"2014-8","tags":[{"count":503,"name":"Android","title":"Android"},{"count":184,"name":"编程","title":"编程"},{"count":149,"name":"移动开发","title":"移动开发"},{"count":124,"name":"入门","title":"入门"},{"count":111,"name":"很适合初学者的一本书","title":"很适合初学者的一本书"},{"count":75,"name":"计算机","title":"计算机"},{"count":59,"name":"软件开发","title":"软件开发"},{"count":57,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s28351121.jpg","binding":"平装","translator":[],"catalog":"第1章  开始启程，你的第一行Android代码  1\n1.1  了解全貌，Android王国简介  2\n1.1.1  Android系统架构  2\n1.1.2  Android已发布的版本  3\n1.1.3  Android应用开发特色  4\n1.2  手把手带你搭建开发环境  5\n1.2.1  准备所需要的软件  5\n1.2.2  搭建开发环境  6\n1.3  创建你的第一个Android项目  11\n1.3.1  创建HelloWorld项目  11\n1.3.2  运行HelloWorld  14\n1.3.3  分析你的第一个Android程序  16\n1.3.4  详解项目中的资源  20\n1.4  前行必备，掌握日志工具的使用  22\n1.4.1  添加LogCat到你的Eclipse  22\n1.4.2  使用Android的日志工具Log  23\n1.4.3  为什么使用Log而不使用System.out  24\n1.5  小结与点评  26\n第2章  先从看得到的入手，探究活动  28\n2.1  活动是什么  28\n2.2  活动的基本用法  28\n2.2.1  手动创建活动  29\n2.2.2  创建和加载布局  30\n2.2.3  在AndroidManifest文件中注册  34\n2.2.4  隐藏标题栏  35\n2.2.5  在活动中使用Toast  36\n2.2.6  在活动中使用Menu  38\n2.2.7  销毁一个活动  41\n2.3  使用Intent在活动之间穿梭  41\n2.3.1  使用显式Intent  41\n2.3.2  使用隐式Intent  44\n2.3.3  更多隐式Intent的用法  46\n2.3.4  向下一个活动传递数据  51\n2.3.5  返回数据给上一个活动  52\n2.4  活动的生命周期  55\n2.4.1  返回栈  55\n2.4.2  活动状态  56\n2.4.3  活动的生存期  56\n2.4.4  体验活动的生命周期  58\n2.4.5  活动被回收了怎么办  66\n2.5  活动的启动模式  68\n2.5.1  standard  68\n2.5.2  singleTop  70\n2.5.3  singleTask  72\n2.5.4  singleInstance  74\n2.6  活动的最佳实践  77\n2.6.1  知晓当前是在哪一个活动  77\n2.6.2  随时随地退出程序  78\n2.6.3  启动活动的最佳写法  80\n2.7  小结与点评  81\n第3章  软件也要拼脸蛋，UI开发的点点滴滴  83\n3.1  该如何编写程序界面  83\n3.2  常见控件的使用方法  84\n3.2.1  TextView  84\n3.2.2  Button  88\n3.2.3  EditText  90\n3.2.4  ImageView  95\n3.2.5  ProgressBar  97\n3.2.6  AlertDialog  101\n3.2.7  ProgressDialog  103\n3.3  详解四种基本布局  105\n3.3.1  LinearLayout  105\n3.3.2  RelativeLayout  112\n3.3.3  FrameLayout  116\n3.3.4  TableLayout  117\n3.4  系统控件不够用？创建自定义控件  120\n3.4.1  引入布局  121\n3.4.2  创建自定义控件  124\n3.5  最常用和最难用的控件\u2014\u2014ListView  127\n3.5.1  ListView的简单用法  127\n3.5.2  定制ListView的界面  129\n3.5.3  提升ListView的运行效率  133\n3.5.4  ListView的点击事件  135\n3.6  单位和尺寸  137\n3.6.1  px和pt的窘境  137\n3.6.2  dp和sp来帮忙  139\n3.7  编写界面的最佳实践  141\n3.7.1  制作Nine-Patch图片  141\n3.7.2  编写精美的聊天界面  145\n3.8  小结与点评  151\n第4章  手机平板要兼顾，探究碎片  153\n4.1  碎片是什么  153\n4.2  碎片的使用方式  155\n4.2.1  碎片的简单用法  157\n4.2.2  动态添加碎片  160\n4.2.3  在碎片中模拟返回栈  163\n4.2.4  碎片和活动之间进行通信  164\n4.3  碎片的生命周期  165\n4.3.1  碎片的状态和回调  165\n4.3.2  体验碎片的生命周期  168\n4.4  动态加载布局的技巧  171\n4.4.1  使用限定符  171\n4.4.2  使用最小宽度限定符  174\n4.5  碎片的最佳实践\u2014\u2014一个简易版的新闻应用  175\n4.6  小结与点评  187\n第5章  全局大喇叭，详解广播机制  188\n5.1  广播机制简介  188\n5.2  接收系统广播  189\n5.2.1  动态注册监听网络变化  190\n5.2.2  静态注册实现开机启动  194\n5.3  发送自定义广播  196\n5.3.1  发送标准广播  197\n5.3.2  发送有序广播  199\n5.4  使用本地广播  202\n5.5  广播的最佳实践\u2014\u2014实现强制下线功能  205\n5.6  Git时间，初识版本控制工具  215\n5.6.1  安装Git  215\n5.6.2  创建代码仓库  216\n5.6.3  提交本地代码  218\n5.7  小结与点评  218\n第6章  数据存储全方案，详解持久化技术  220\n6.1  持久化技术简介  220\n6.2  文件存储  221\n6.2.1  将数据存储到文件中  221\n6.2.2  从文件中读取数据  225\n6.3  SharedPreferences存储  228\n6.3.1  将数据存储到SharedPreferences中  229\n6.3.2  从SharedPreferences中读取数据  232\n6.3.3  实现记住密码功能  234\n6.4  SQLite数据库存储  238\n6.4.1  创建数据库  239\n6.4.2  升级数据库  245\n6.4.3  添加数据  248\n6.4.4  更新数据  251\n6.4.5  删除数据  254\n6.4.6  查询数据  256\n6.4.7  使用SQL操作数据库  260\n6.5  SQLite数据库的最佳实践  260\n6.5.1  使用事务  261\n6.5.2  升级数据库的最佳写法  263\n6.6  小结与点评  266\n第7章  跨程序共享数据，探究内容提供器  268\n7.1  内容提供器简介  268\n7.2  访问其他程序中的数据  269\n7.2.1  ContentResolver的基本用法  269\n7.2.2  读取系统联系人  271\n7.3  创建自己的内容提供器  275\n7.3.1  创建内容提供器的步骤  276\n7.3.2  实现跨程序数据共享  281\n7.4  Git时间，版本控制工具进阶  292\n7.4.1  忽略文件  292\n7.4.2  查看修改内容  293\n7.4.3  撤销未提交的修改  295\n7.4.4  查看提交记录  296\n7.5  小结与点评  297\n第8章  丰富你的程序，运用手机多媒体  298\n8.1  使用通知  298\n8.1.1  通知的基本用法  298\n8.1.2  通知的高级技巧  305\n8.2  接收和发送短信  307\n8.2.1  接收短信  308\n8.2.2  拦截短信  313\n8.2.3  发送短信  314\n8.3  调用摄像头和相册  320\n8.3.1  将程序运行到手机上  320\n8.3.2  调用摄像头拍照  322\n8.3.3  从相册中选择照片  327\n8.4  播放多媒体文件  331\n8.4.1  播放音频  332\n8.4.2  播放视频  336\n8.5  小结与点评  340\n第9章  后台默默的劳动者，探究服务  341\n9.1  服务是什么  341\n9.2  Android多线程编程  341\n9.2.1  线程的基本用法  342\n9.2.2  在子线程中更新UI  343\n9.2.3  解析异步消息处理机制  348\n9.2.4  使用AsyncTask  349\n9.3  服务的基本用法  353\n9.3.1  定义一个服务  353\n9.3.2  启动和停止服务  355\n9.3.3  活动和服务进行通信  359\n9.4  服务的生命周期  363\n9.5  服务的更多技巧  364\n9.5.1  使用前台服务  364\n9.5.2  使用IntentService  367\n9.6  服务的最佳实践\u2014\u2014后台执行的定时任务  371\n9.7  小结与点评  376\n第10章  看看精彩的世界，使用网络技术  377\n10.1  WebView的用法  377\n10.2  使用HTTP协议访问网络  380\n10.2.1  使用HttpURLConnection  380\n10.2.2  使用HttpClient  385\n10.3  解析XML格式数据  388\n10.3.1  Pull解析方式  391\n10.3.2  SAX解析方式  394\n10.4  解析JSON格式数据  398\n10.4.1  使用JSONObject  399\n10.4.2  使用GSON  401\n10.5  网络编程的最佳实践  404\n10.6  小结与点评  408\n第11章  Android特色开发，基于位置的服务  409\n11.1  基于位置的服务简介  409\n11.2  找到自己的位置  409\n11.2.1  LocationManager的基本用法  410\n11.2.2  确定自己位置的经纬度  412\n11.3  反向地理编码，看得懂的位置信息  415\n11.3.1  Geocoding API的用法  416\n11.3.2  对经纬度进行解析  417\n11.4  使用百度地图  420\n11.4.1  申请API Key  420\n11.4.2  让地图显示出来  423\n11.4.3  定位到我的位置  427\n11.4.4  使用覆盖物来增加更多功能  430\n11.5  Git时间，版本控制工具的高级用法  434\n11.5.1  分支的用法  434\n11.5.2  与远程版本库协作  437\n11.6  小结与点评  438\n第12章  Android特色开发，使用传感器  439\n12.1  传感器简介  439\n12.2  光照传感器  439\n12.2.1  光照传感器的用法  440\n12.2.2  制作简易光照探测器  441\n12.3  加速度传感器  443\n12.3.1  加速度传感器的用法  443\n12.3.2  模仿微信摇一摇  444\n12.4  方向传感器  446\n12.4.1  方向传感器的用法  446\n12.4.2  制作简易指南针  448\n12.5  小结与点评  453\n第13章  继续进阶，你还应该掌握的高级技巧  455\n13.1  全局获取Context的技巧  455\n13.2  使用Intent传递对象  459\n13.2.1  Serializable方式  459\n13.2.2  Parcelable方式  461\n13.3  定制自己的日志工具  462\n13.4  调试Android程序  464\n13.5  编写测试用例  468\n13.5.1  创建测试工程  468\n13.5.2  进行单元测试  471\n13.6  总结  474\n第14章  进入实战，开发酷欧天气  476\n14.1  功能需求及技术可行性分析  476\n14.2  Git时间，将代码托管到GitHub上  478\n14.3  创建数据库和表  485\n14.4  遍历全国省市县数据  494\n14.5  显示天气信息  507\n14.6  切换城市和手动更新天气  519\n14.7  后台自动更新天气  523\n14.8  修改图标和名称  526\n14.9  你还可以做的事情  528\n第15章  最后一步，将应用发布到Google Play  530\n15.1  生成正式签名的APK文件  530\n15.2  申请Google Play账号  533\n15.3  上传和发布应用程序  534\n15.4  嵌入广告进行盈利  541\n15.4.1  注册有米账号和验证身份  542\n15.4.2  下载和接入有米SDK  544\n15.4.3  重新发布应用程序  550\n15.5  结束语  553","pages":"553","images":{"small":"https://img3.doubanio.com/spic/s28351121.jpg","large":"https://img3.doubanio.com/lpic/s28351121.jpg","medium":"https://img3.doubanio.com/mpic/s28351121.jpg"},"alt":"https://book.douban.com/subject/25942191/","id":"25942191","publisher":"人民邮电出版社","isbn10":"7115362866","isbn13":"9787115362865","title":"第一行代码","url":"https://api.douban.com/v2/book/25942191","alt_title":"","author_intro":"郭霖，Android软件开发工程师。从事Android开发工作四年，有着丰富的项目实战经验，负责及参与开发过多款移动应用与游戏，对Android系统架构及应用层开发有着深入的理解。2013年3月开始，在CSDN上发表Android技术相关博文，很快就获得了大量网友的好评。短短一年时间博客访问量超过50万次，评价近3000条。荣获CSDN认证专家，并被评选为2013年CSDN年度博客之星。现就职于蜗牛移动，继续从事Android开发工作。","summary":"《第一行代码\u2014\u2014Android》是Android初学者的最佳入门书。全书由浅入深、系统全面地讲解了Android软件开发的方方面面。第1章带领你搭建Android开发环境，完成你的第一个Android程序。第2章至第13章完整地讲解了Android开发中的各种基本知识和关键技术，包括四大组件、UI、碎片、广播机制、数据存储、服务、多媒体、网络、定位服务、传感器，以及分布式版本控制系统Git的使用等等。在部分章节会穿插相关技术的高级使用技巧。第14章和第15章则将带领你编写一个完整的项目，教会你如何打包、上架、嵌入广告并获得盈利。《第一行代码\u2014\u2014Android》内容通俗易懂，既适合初学者循序渐进地阅读，也可作为一本参考手册，随时查阅。","price":"79.00元"},{"rating":{"max":10,"numRaters":3136,"average":"8.7","min":0},"subtitle":"","author":["(美)菲利普·迪克"],"pubdate":"2013-9","tags":[{"count":1364,"name":"科幻","title":"科幻"},{"count":610,"name":"菲利普·迪克","title":"菲利普·迪克"},{"count":533,"name":"美国","title":"美国"},{"count":510,"name":"小说","title":"小说"},{"count":496,"name":"科幻小说","title":"科幻小说"},{"count":379,"name":"赛博朋克","title":"赛博朋克"},{"count":378,"name":"菲利普·K.迪克","title":"菲利普·K.迪克"},{"count":203,"name":"外国文学","title":"外国文学"}],"origin_title":"Do Androids Dream of Electric Sheep?","image":"https://img3.doubanio.com/mpic/s26858994.jpg","binding":"平装","translator":["许东华"],"catalog":"小说正文\n译后记","pages":"200","images":{"small":"https://img3.doubanio.com/spic/s26858994.jpg","large":"https://img3.doubanio.com/lpic/s26858994.jpg","medium":"https://img3.doubanio.com/mpic/s26858994.jpg"},"alt":"https://book.douban.com/subject/24715686/","id":"24715686","publisher":"译林出版社","isbn10":"7544738760","isbn13":"9787544738767","title":"仿生人会梦见电子羊吗？","url":"https://api.douban.com/v2/book/24715686","alt_title":"Do Androids Dream of Electric Sheep?","author_intro":"Philip K. Dick：\n粉丝昵称PKD。\n美国科幻文学界的传奇人物，在美国科幻黄金时代独树一帜。\n共出版44部长篇小说和121个短篇小说，曾获雨果奖和坎贝尔奖。\n作品集中探讨何为真实以及个体身份建构。赋予科幻以复杂的文学性、心理深度以及社会警示意义 ，是美国最早一批使科幻 严肃起来的作家之一。\n盛名经久不衰，有多部作品被改编成电影，包括《银翼杀手》、《少数派报告》、《全面回忆》等，一再催生票房新高。\n以其名字命名的菲利普\u2022K.迪克奖是美国科幻界的主要奖项之一。","summary":"核战后，放射尘让地球上的动物濒临灭绝，地球已不再适合人类居住。为了鼓励残存的人口移民，政府承诺，只要 移民到外 星球，就可以为每个人自动配备一个仿生人帮助其生活。仿生人不满足于被人类奴役的现状，想方设法逃回地球。\n主人公里克\u2022德卡德是一名专门追捕逃亡仿生人的赏金猎人。在一次 追捕行动中，里克遭遇了新型仿生人前所未有的挑战。九死之后，能否一生？在与仿生人的接触和较量中，里克发现自己对仿生人的看法和态度有了很大的改变。这种改变究竟是福还是祸？","series":{"id":"18923","title":"菲利普·迪克作品：译林版"},"price":"28.00元"},{"rating":{"max":10,"numRaters":149,"average":"8.5","min":0},"subtitle":"Android","author":["郭霖"],"pubdate":"2016-12-1","tags":[{"count":97,"name":"Android","title":"Android"},{"count":52,"name":"特别适合Android初学者的书","title":"特别适合Android初学者的书"},{"count":41,"name":"移动开发","title":"移动开发"},{"count":38,"name":"编程","title":"编程"},{"count":38,"name":"安卓开发","title":"安卓开发"},{"count":31,"name":"安卓","title":"安卓"},{"count":30,"name":"android","title":"android"},{"count":28,"name":"Java","title":"Java"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s29572743.jpg","binding":"平装","translator":[],"catalog":"第1章　开始启程\u2014\u2014你的第一行Android代码　　1\n1.1　了解全貌\u2014\u2014Android王国简介　　2\n1.1.1　Android系统架构　　2\n1.1.2　Android已发布的版本　　3\n1.1.3　Android应用开发特色　　4\n1.2　手把手带你搭建开发环境　　5\n1.2.1　准备所需要的工具　　5\n1.2.2　搭建开发环境　　5\n1.3　创建你的第一个Android项目　　9\n1.3.1　创建HelloWorld项目　　9\n1.3.2　启动模拟器　　12\n1.3.3　运行HelloWorld　　15\n1.3.4　分析你的第一个Android程序　　16\n1.3.5　详解项目中的资源　　22\n1.3.6　详解build.gradle文件　　23\n1.4　前行必备\u2014\u2014掌握日志工具的使用　　26\n1.4.1　使用Android的日志工具Log　　26\n1.4.2　为什么使用Log而不使用System.out　　27\n1.5　小结与点评　　29\n第2章　先从看得到的入手\u2014\u2014探究活动　　30\n2.1　活动是什么　　30\n2.2　活动的基本用法　　30\n2.2.1　手动创建活动　　31\n2.2.2　创建和加载布局　　32\n2.2.3　在AndroidManifest文件中注册　　35\n2.2.4　在活动中使用Toast　　37\n2.2.5　在活动中使用Menu　　38\n2.2.6　销毁一个活动　　40\n2.3　使用Intent在活动之间穿梭　　41\n2.3.1　使用显式Intent　　41\n2.3.2　使用隐式Intent　　44\n2.3.3　更多隐式Intent的用法　　46\n2.3.4　向下一个活动传递数据　　50\n2.3.5　返回数据给上一个活动　　51\n2.4　活动的生命周期　　53\n2.4.1　返回栈　　53\n2.4.2　活动状态　　54\n2.4.3　活动的生存期　　55\n2.4.4　体验活动的生命周期　　56\n2.4.5　活动被回收了怎么办　　62\n2.5　活动的启动模式　　63\n2.5.1　standard　　64\n2.5.2　singleTop　　65\n2.5.3　singleTask　　67\n2.5.4　singleInstance　　68\n2.6　活动的最佳实践　　71\n2.6.1　知晓当前是在哪一个活动　　71\n2.6.2　随时随地退出程序　　72\n2.6.3　启动活动的最佳写法　　74\n2.7　小结与点评　　75\n第3章　软件也要拼脸蛋\u2014\u2014UI开发的点点滴滴　　76\n3.1　如何编写程序界面　　76\n3.2　常用控件的使用方法　　77\n3.2.1　TextView　　77\n3.2.2　Button　　80\n3.2.3　EditText　　82\n3.2.4　ImageView　　86\n3.2.5　ProgressBar　　88\n3.2.6　AlertDialog　　91\n3.2.7　ProgressDialog　　93\n3.3　详解4种基本布局　　94\n3.3.1　线性布局　　94\n3.3.2　相对布局　　100\n3.3.3　帧布局　　103\n3.3.4　百分比布局　　105\n3.4　系统控件不够用？创建自定义控件　　108\n3.4.1　引入布局　　109\n3.4.2　创建自定义控件　　111\n3.5　最常用和最难用的控件\u2014\u2014ListView　　113\n3.5.1　ListView的简单用法　　114\n3.5.2　定制ListView的界面　　115\n3.5.3　提升ListView的运行效率　　119\n3.5.4　ListView的点击事件　　120\n3.6　更强大的滚动控件\u2014\u2014RecyclerView　　122\n3.6.1　RecyclerView的基本用法　　122\n3.6.2　实现横向滚动和瀑布流布局　　125\n3.6.3　RecyclerView的点击事件　　130\n3.7　编写界面的最佳实践　　132\n3.7.1　制作Nine-Patch图片　　132\n3.7.2　编写精美的聊天界面　　135\n3.8　小结与点评　　141\n第4章　手机平板要兼顾\u2014\u2014探究碎片　　142\n4.1　碎片是什么　　142\n4.2　碎片的使用方式　　144\n4.2.1　碎片的简单用法　　144\n4.2.2　动态添加碎片　　147\n4.2.3　在碎片中模拟返回栈　　150\n4.2.4　碎片和活动之间进行通信　　151\n4.3　碎片的生命周期　　151\n4.3.1　碎片的状态和回调　　151\n4.3.2　体验碎片的生命周期　　153\n4.4　动态加载布局的技巧　　156\n4.4.1　使用限定符　　156\n4.4.2　使用最小宽度限定符　　159\n4.5　碎片的最佳实践\u2014\u2014一个简易版的新闻应用　　160\n4.6　小结与点评　　169\n第5章　全局大喇叭\u2014\u2014详解广播机制　　170\n5.1　广播机制简介　　170\n5.2　接收系统广播　　171\n5.2.1　动态注册监听网络变化　　171\n5.2.2　静态注册实现开机启动　　174\n5.3　发送自定义广播　　177\n5.3.1　发送标准广播　　177\n5.3.2　发送有序广播　　179\n5.4　使用本地广播　　183\n5.5　广播的最佳实践\u2014\u2014实现强制下线功能　　185\n5.6　Git时间\u2014\u2014初识版本控制工具　　192\n5.6.1　安装Git　　192\n5.6.2　创建代码仓库　　193\n5.6.3　提交本地代码　　195\n5.7　小结与点评　　195\n第6章　数据存储全方案\u2014\u2014详解持久化技术　　196\n6.1　持久化技术简介　　196\n6.2　文件存储　　197\n6.2.1　将数据存储到文件中　　197\n6.2.2　从文件中读取数据　　201\n6.3　SharedPreferences存储　　203\n6.3.1　将数据存储到SharedPreferences中　　203\n6.3.2　从SharedPreferences中读取数据　　206\n6.3.3　实现记住密码功能　　208\n6.4　SQLite数据库存储　　211\n6.4.1　创建数据库　　211\n6.4.2　升级数据库　　216\n6.4.3　添加数据　　219\n6.4.4　更新数据　　222\n6.4.5　删除数据　　224\n6.4.6　查询数据　　225\n6.4.7　使用SQL操作数据库　　228\n6.5　使用LitePal操作数据库　　229\n6.5.1　LitePal简介　　229\n6.5.2　配置LitePal　　230\n6.5.3　创建和升级数据库　　231\n6.5.4　使用LitePal添加数据　　236\n6.5.5　使用LitePal更新数据　　237\n6.5.6　使用LitePal删除数据　　240\n6.5.7　使用LitePal查询数据　　241\n6.6　小结与点评　　243\n第7章　跨程序共享数据\u2014\u2014探究内容提供器　　244\n7.1　内容提供器简介　　244\n7.2　运行时权限　　245\n7.2.1　Android权限机制详解　　245\n7.2.2　在程序运行时申请权限　　249\n7.3　访问其他程序中的数据　　254\n7.3.1　ContentResolver的基本用法　　254\n7.3.2　读取系统联系人　　256\n7.4　创建自己的内容提供器　　260\n7.4.1　创建内容提供器的步骤　　261\n7.4.2　实现跨程序数据共享　　265\n7.5　Git时间\u2014\u2014版本控制工具进阶　　275\n7.5.1　忽略文件　　275\n7.5.2　查看修改内容　　276\n7.5.3　撤销未提交的修改　　278\n7.5.4　查看提交记录　　279\n7.6　小结与点评　　280\n第8章　丰富你的程序\u2014\u2014运用手机多媒体　　281\n8.1　将程序运行到手机上　　281\n8.2　使用通知　　283\n8.2.1　通知的基本用法　　283\n8.2.2　通知的进阶技巧　　289\n8.2.3　通知的高级功能　　291\n8.3　调用摄像头和相册　　293\n8.3.1　调用摄像头拍照　　294\n8.3.2　从相册中选择照片　　298\n8.4　播放多媒体文件　　303\n8.4.1　播放音频　　303\n8.4.2　播放视频　　307\n8.5　小结与点评　　311\n第9章　看看精彩的世界\u2014\u2014使用网络技术　　312\n9.1　WebView的用法　　312\n9.2　使用HTTP协议访问网络　　314\n9.2.1　使用HttpURLConnection　　315\n9.2.2　使用OkHttp　　319\n9.3　解析XML格式数据　　321\n9.3.1　Pull解析方式　　324\n9.3.2　SAX解析方式　　326\n9.4　解析JSON格式数据　　329\n9.4.1　使用JSONObject　　330\n9.4.2　使用GSON　　331\n9.5　网络编程的最佳实践　　334\n9.6　小结与点评　　338\n第10章　后台默默的劳动者\u2014\u2014探究服务　　339\n10.1　服务是什么　　339\n10.2　Android多线程编程　　340\n10.2.1　线程的基本用法　　340\n10.2.2　在子线程中更新UI　　341\n10.2.3　解析异步消息处理机制　　345\n10.2.4　使用AsyncTask　　347\n10.3　服务的基本用法　　349\n10.3.1　定义一个服务　　349\n10.3.2　启动和停止服务　　352\n10.3.3　活动和服务进行通信　　355\n10.4　服务的生命周期　　359\n10.5　服务的更多技巧　　359\n10.5.1　使用前台服务　　359\n10.5.2　使用IntentService　　361\n10.6　服务的最佳实践\u2014\u2014完整版的下载示例　　365\n10.7　小结与点评　　378\n第11章　Android特色开发\u2014\u2014基于位置的服务　　379\n11.1　基于位置的服务简介　　379\n11.2　申请API Key　　380\n11.3　使用百度定位　　384\n11.3.1　准备LBS SDK　　384\n11.3.2　确定自己位置的经纬度　　386\n11.3.3　选择定位模式　　391\n11.3.4　看得懂的位置信息　　393\n11.4　使用百度地图　　395\n11.4.1　让地图显示出来　　395\n11.4.2　移动到我的位置　　397\n11.4.3　让\u201c我\u201d显示在地图上　　400\n11.5　Git时间\u2014\u2014版本控制工具的高级用法　　402\n11.5.1　分支的用法　　403\n11.5.2　与远程版本库协作　　404\n11.6　小结与点评　　406\n第12章　最佳的UI体验\u2014\u2014MaterialDesign实战　　407\n12.1　什么是Material Design　　407\n12.2　Toolbar　　408\n12.3　滑动菜单　　415\n12.3.1　DrawerLayout　　415\n12.3.2　NavigationView　　418\n12.4　悬浮按钮和可交互提示　　423\n12.4.1　FloatingActionButton　　424\n12.4.2　Snackbar　　427\n12.4.3　CoordinatorLayout　　428\n12.5　卡片式布局　　430\n12.5.1　CardView　　431\n12.5.2　AppBarLayout　　437\n12.6　下拉刷新　　440\n12.7　可折叠式标题栏　　443\n12.7.1　CollapsingToolbarLayout　　443\n12.7.2　充分利用系统状态栏空间　　453\n12.8　小结与点评　　456\n第13章　继续进阶\u2014\u2014你还应该掌握的高级技巧　　457\n13.1　全局获取Context的技巧　　457\n13.2　使用Intent传递对象　　461\n13.2.1　Serializable方式　　461\n13.2.2　Parcelable方式　　463\n13.3　定制自己的日志工具　　464\n13.4　调试Android程序　　466\n13.5　创建定时任务　　469\n13.5.1　Alarm机制　　469\n13.5.2　Doze模式　　471\n13.6　多窗口模式编程　　472\n13.6.1　进入多窗口模式　　473\n13.6.2　多窗口模式下的生命周期　　475\n13.6.3　禁用多窗口模式　　479\n13.7　Lambda表达式　　481\n13.8　总结　　485\n第14章　进入实战\u2014\u2014开发酷欧天气　　486\n14.1　功能需求及技术可行性分析　　486\n14.2　Git时间\u2014\u2014将代码托管到GitHub上　　489\n14.3　创建数据库和表　　494\n14.4　遍历全国省市县数据　　499\n14.5　显示天气信息　　509\n14.5.1　定义GSON实体类　　509\n14.5.2　编写天气界面　　514\n14.5.3　将天气显示到界面上　　520\n14.5.4　获取必应每日一图　　526\n14.6　手动更新天气和切换城市　　532\n14.6.1　手动更新天气　　532\n14.6.2　切换城市　　535\n14.7　后台自动更新天气　　540\n14.8　修改图标和名称　　542\n14.9　你还可以做的事情　　543\n第15章　最后一步\u2014\u2014将应用发布到360应用商店　　545\n15.1　生成正式签名的APK文件　　545\n15.1.1　使用Android Studio生成　　546\n15.1.2　使用Gradle生成　　548\n15.1.3　生成多渠道APK文件　　551\n15.2　申请360开发者账号　　554\n15.3　发布应用程序　　556\n15.4　嵌入广告进行盈利　　560\n15.4.1　注册腾讯广告联盟账号　　560\n15.4.2　新建媒体和广告位　　562\n15.4.3　接入广告SDK　　564\n15.4.4　重新发布应用程序　　569\n15.5　结束语　　570","ebook_url":"https://read.douban.com/ebook/35604638/","pages":"570","images":{"small":"https://img3.doubanio.com/spic/s29572743.jpg","large":"https://img3.doubanio.com/lpic/s29572743.jpg","medium":"https://img3.doubanio.com/mpic/s29572743.jpg"},"alt":"https://book.douban.com/subject/26915433/","id":"26915433","publisher":"人民邮电出版社","isbn10":"7115439788","isbn13":"9787115439789","title":"第一行代码：Android（第2版）","url":"https://api.douban.com/v2/book/26915433","alt_title":"","author_intro":"郭霖\nAndroid软件开发工程师。从事Android开发工作6年，有着丰富的项目实战经验，负责及参与开发过多款移动应用与游戏，对Android系统架构及应用层开发有着深入的理解。\n2013年3月开始，在CSDN上发表Android技术相关博文，很快获得了大量网友的好评。目前博客访问量已超过500万次，评论超过10000条。荣获CSDN认证专家，并被连续评选为CSDN 2013、2014、2015年度博客之星。","summary":"本书被广大Android 开发者誉为\u201cAndroid 学习第一书\u201d。全书系统全面、循序渐进地介绍了Android软件开发的必备知识、经验和技巧。\n第2版基于Android 7.0 对第1 版进行了全面更新，将所有知识点都在最新的Android 系统上进行重新适配，使用 全新的Android Studio 开发工具代替之前的Eclipse，并添加了对Material Design、运行时权限、Gradle、RecyclerView、百分比布局、OkHttp、Lambda 表达式等全新知识点的详细讲解。\n本书内容通俗易懂，由浅入深，既是Android 初学者的入门必备，也是Android 开发者的进阶首选。","ebook_price":"39.99","price":"CNY 79.00"},{"rating":{"max":10,"numRaters":20,"average":"5.1","min":0},"subtitle":"A Programmer's Guide","author":["J.F. DiMarzio"],"pubdate":"2008-7-30","tags":[{"count":16,"name":"Android","title":"Android"},{"count":6,"name":"Mobile","title":"Mobile"},{"count":4,"name":"Google","title":"Google"},{"count":3,"name":"Phone","title":"Phone"},{"count":2,"name":"技术","title":"技术"},{"count":1,"name":"开发技术","title":"开发技术"},{"count":1,"name":"力的来源!","title":"力的来源!"},{"count":1,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s4259006.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"400","images":{"small":"https://img3.doubanio.com/spic/s4259006.jpg","large":"https://img3.doubanio.com/lpic/s4259006.jpg","medium":"https://img3.doubanio.com/mpic/s4259006.jpg"},"alt":"https://book.douban.com/subject/3134548/","id":"3134548","publisher":"McGraw-Hill Osborne Media","isbn10":"0071599886","isbn13":"9780071599887","title":"Android","url":"https://api.douban.com/v2/book/3134548","alt_title":"","author_intro":"","summary":"Master the Android mobile development platform  Build compelling Java-based mobile applications using the Android SDK and the Eclipse open-source software development platform. Android: A Programmer's Guide shows you, step-by-step, how to download and set up all of the necessary tools, build and tune dynamic Android programs, and debug your results. Discover how to provide web and chat functions, interact with the phone dialer and GPS devices, and access the latest Google services. You'll also learn how to create custom Content Providers and database-enable your applications using SQLite.  Install and configure Java, Eclipse, and Android plugin  Create Android projects from the Eclipse UI or command line  Integrate web content, images, galleries, and sounds  Deploy menus, progress bars, and auto-complete functions  Trigger actions using Android Intents, Filters, and Receivers  Implement GPS, Google Maps, Google Earth, and GTalk Build interactive SQLite databases, calendars, and notepads  Test applications using the Android Emulator and Debug Bridge","price":"USD 39.99"},{"rating":{"max":10,"numRaters":83,"average":"7.2","min":0},"subtitle":"你的第一本Android书","author":["[美] Ed Burnette"],"pubdate":"2009-11","tags":[{"count":162,"name":"Android","title":"Android"},{"count":51,"name":"手机开发","title":"手机开发"},{"count":24,"name":"编程","title":"编程"},{"count":19,"name":"计算机","title":"计算机"},{"count":12,"name":"入门","title":"入门"},{"count":7,"name":"programming","title":"programming"},{"count":7,"name":"IT","title":"IT"},{"count":6,"name":"android","title":"android"}],"origin_title":"Hello, Android : Introducing Google's Mobile Development Platform","image":"https://img3.doubanio.com/mpic/s6089496.jpg","binding":"平装","translator":["高朝勤","杨越"],"catalog":"第一部分　Android简介\n第1章　快速入门\n1.1　安装工具\n1.1.1　Java 5.0+\n1.1.2　Eclipse\n1.1.3　Android\n1.1.4　Eclipse插件\n1.2　创建第一个程序\n1.3　在模拟器上运行程序\n1.4　在手机上运行程序\n1.5　快速阅读指南\n第2章　基本概念\n2.1　Android的系统架构\n2.1.1　Linux内核\n2.1.2　本机库\n2.1.3　Android运行时\n2.1.4　应用程序框架\n2.1.5　应用程序\n2.2　它还活着\n2.2.1　进程不等于应用程序\n2.2.2　应用程序生命周期\n2.3　构建块\n2.3.1　活动\n2.3.2　意图\n2.3.3　服务\n2.3.4　内容提供者\n2.4　使用资源\n2.5　安全性\n2.6　快速阅读指南\n第二部分　Android基础知识\n第3章　设计用户界面\n3.1　数独游戏简介\n3.2　声明性设计\n3.3　创建启动界面\n3.4　使用替代资源\n3.5　实现About对话框\n3.6　应用主题\n3.7　添加菜单\n3.8　添加设置\n3.9　开始新游戏\n3.10　利用日志消息调试程序\n3.11　利用调试器调试程序\n3.12　退出游戏\n3.13　快速阅读指南\n第4章　绘制2D图形\n4.1　Android图形基础\n4.1.1　Color类\n4.1.2　Paint类\n4.1.3　Canvas类\n4.1.4　Path类\n4.1.5　Drawable类\n4.2　在Sudoku程序中添加图形\n4.2.1　开始游戏\n4.2.2　定义Game类\n4.2.3　定义PuzzleView类\n4.2.4　绘制游戏盘面\n4.2.5　绘制数字\n4.3　处理输入\n4.3.1　定义和更新选定区域\n4.3.2　输入数字\n4.3.3　增加提示\n4.3.4　抖动屏幕\n4.4　其他问题\n4.4.1　创建软键盘\n4.4.2　实现游戏逻辑\n4.4.3　其他功能\n4.5　更多改进\n4.6　快速阅读指南\n第5章　多媒体\n5.1　播放音频\n5.2　播放视频\n5.3　为数独游戏配上音乐\n5.4　快速阅读指南\n第6章　存储本地数据\n6.1　为数独游戏添加选项\n6.2　继续玩前一个游戏\n6.3　记住当前位置\n6.4　访问内部文件系统\n6.5　访问SD卡\n6.6　快速阅读指南\n第三部分　高级主题\n第7章　互联的世界\n7.1　通过意图实现浏览\n7.2　利用视图打开网页\n7.3　JavaScript与Java通信\n7.4　使用Web服务\n7.5　快速阅读指南\n第8章　定位与环境感知\n8.1　位置，位置，位置\n8.1.1　我在哪里\n8.1.2　更新位置\n8.1.3　模拟说明\n8.2　充分利用传感器\n8.2.1　了解传感器\n8.2.2　解析传感器的读数\n8.2.3　模拟说明\n8.3　地图功能\n8.3.1　嵌入MapView\n8.3.2　准备就绪\n8.3.3　模拟说明\n8.4　快速阅读指南\n第9章　SQL实战\n9.1　SQLite简介\n9.2　SQL基础\n9.2.1　DDL语句\n9.2.2　修改语句\n9.2.3　查询语句\n9.3　你好，数据库\n9.3.1　使用SQliteOpenHelper\n9.3.2　定义主程序\n9.3.3　添加一行\n9.3.4　运行一个查询\n9.3.5　显示查询结果\n9.4　数据绑定\n9.5　使用ContentProvider\n9.5.1　更改主程序\n9.5.2　添加一行\n9.5.3　运行一个查询\n9.6　实现ContentProvider\n9.7　快速阅读指南\n第10章　利用OpenGL实现3D图形\n10.1　理解3D图形\n10.2　OpenGL简介\n10.3　构建一个OpenGL程序\n10.4　管理线程\n10.5　构建一个模型\n10.6　光线、相机\n10.7　动作\n10.8　应用纹理\n10.9　透明效果\n10.10　快速阅读指南\n第四部分　附录\n附录A　Java与Android语言及其API\n附录B　参考书目","pages":"196","images":{"small":"https://img3.doubanio.com/spic/s6089496.jpg","large":"https://img3.doubanio.com/lpic/s6089496.jpg","medium":"https://img3.doubanio.com/mpic/s6089496.jpg"},"alt":"https://book.douban.com/subject/4111350/","id":"4111350","publisher":"人民邮电出版社","isbn10":"7115215367","isbn13":"9787115215369","title":"Android基础教程","url":"https://api.douban.com/v2/book/4111350","alt_title":"Hello, Android : Introducing Google's Mobile Development Platform","author_intro":"Ed Burnette 资深软件技术专家，拥有20多年软件开发经验。SAS高级计算机实验室的联合创始人和高级研究员。他是www.planetandroid.com网站的创办人和ZDNet的专栏作家。除本书外，他还出版了Google Web Toolkit: Taking the Pain out of Ajax和 Eclipse IDE Pocket Guide等著作。","summary":"《Android基础教程》内容完整丰富，具有较强的通用性，读者都能通过《Android基础教程》快速学习Android开发，提高相关技能。Android是谷歌公司开发的全新开源手机平台。《Android基础教程》是一部关于Android开发的基础教程，采用由浅入深、循序渐进的方式讨论Android。书中还结合数独游戏等实例更加形象生动地讲解了Android开发的基本流程，且每章最后都有一个\u201c快速阅读指南\u201d，更加方便了读者的阅读。","price":"39.00元"},{"rating":{"max":10,"numRaters":55,"average":"7.4","min":0},"subtitle":"Android权威专家撰写，经典作品最新升级版","author":["(美)迈耶(Meier, R.) 著"],"pubdate":"2013-4-1","tags":[{"count":107,"name":"Android","title":"Android"},{"count":35,"name":"编程","title":"编程"},{"count":19,"name":"计算机","title":"计算机"},{"count":15,"name":"程序设计","title":"程序设计"},{"count":14,"name":"android","title":"android"},{"count":7,"name":"计算机技术","title":"计算机技术"},{"count":6,"name":"技术","title":"技术"},{"count":6,"name":"Android开发","title":"Android开发"}],"origin_title":"Professional Android 4 Application Development","image":"https://img1.doubanio.com/mpic/s26343747.jpg","binding":"平装","translator":["佘建伟","赵凯"],"catalog":"目 录\n第1章  Android简介\t1\n1.1  一些背景信息\t2\n1.1.1  不远的过去\t2\n1.1.2  未来的前景\t2\n1.2  对Android的误解\t3\n1.3  Android：开放的移动开发平台\t3\n1.4  原生Android应用程序\t4\n1.5  Android SDK的特征\t5\n1.5.1  访问硬件(包括摄像头、GPS和\n传感器)\t5\n1.5.2  使用Wi-Fi、蓝牙技术和NFC\n进行数据传输\t6\n1.5.3  地图、地理编码和基于位置的\n服务\t6\n1.5.4  后台服务\t6\n1.5.5  使用SQLite数据库进行数据\n存储和检索\t7\n1.5.6  共享数据和应用程序间通信\t7\n1.5.7  使用Widget和Live Wallpaper\n增强主屏幕\t7\n1.5.8  广泛的媒体支持和2D/3D图形\t7\n1.5.9  Cloud to Device Messaging\t8\n1.5.10  优化的内存和进程管理\t8\n1.6  开放手机联盟简介\t8\n1.7  运行Android的环境\t9\n1.8  从事移动开发的原因\t9\n1.9  从事Android开发的原因\t9\n1.9.1  推动Android普及的因素\t10\n1.9.2  Android的独到之处\t10\n1.9.3  改变移动开发格局\t11\n1.10  开发框架简介\t11\n1.10.1  开发包中的资源\t12\n1.10.2  理解Android软件栈\t12\n1.10.3  Dalvik虚拟机\t14\n1.10.4  Android应用程序架构\t14\n1.10.5  Android库\t15\n第2章  开始入手\t17\n2.1  Android开发\t18\n2.1.1  开始前的准备工作\t18\n2.1.2  创建第一个Android应用程序\t24\n2.1.3  Android应用程序的类型\t31\n2.2  面向移动设备和嵌入式设备的\n开发\t32\n2.2.1  硬件限制带来的设计考虑事项\t32\n2.2.2  考虑用户环境\t35\n2.2.3  Android开发\t36\n2.3  Android开发工具\t40\n2.3.1  Android虚拟设备管理器\t41\n2.3.2  Android SDK管理器\t42\n2.3.3  Android模拟器\t42\n2.3.4  Dalvik调试监控服务(DDMS)\t42\n2.3.5  Android调试桥(ADB)\t43\n2.3.6  Hierarchy Viewer和Lint工具\t43\n2.3.7  Monkey和Monkey Runner\t43\n第3章  创建应用程序和Activity\t45\n3.1  Android应用程序的组成部分\t46\n3.2  应用程序Manifest文件简介\t47\n3.3  使用Manifest编辑器\t54\n3.4  分离资源\t55\n3.4.1  创建资源\t55\n3.4.2  使用资源\t63\n3.4.3  为不同的语言和硬件创建\n资源\t66\n3.4.4  运行时配置更改\t68\n3.5  Android应用程序生命周期\t70\n3.6  理解应用程序的优先级和进程\n状态\t70\n3.7  Android Application类简介\t72\n3.7.1  扩展和使用Application类\t72\n3.7.2  重写应用程序的生命周期\n事件\t73\n3.8  深入探讨Android Activity\t74\n3.8.1  创建Activity\t74\n3.8.2  Activity的生存期\t76\n3.8.3  Android Activity类\t81\n第4章  创建用户界面\t83\n4.1  Android UI基本设计\t84\n4.2  Android UI的基础知识\t84\n4.3  布局简介\t85\n4.3.1  定义布局\t86\n4.3.2  使用布局创建设备无关的UI\t87\n4.3.3  优化布局\t90\n4.4  To-Do List示例\t93\n4.5  Fragment介绍\t100\n4.5.1  创建新的Fragment\t101\n4.5.2  Fragment的生命周期\t101\n4.5.3  Fragment Manager介绍\t105\n4.5.4  向Activity中添加Fragment\t105\n4.5.5  Fragment和Activity之间的\n接口\t110\n4.5.6  没有用户界面的Fragment\t111\n4.5.7  Android Fragment 类\t112\n4.5.8  对To-Do List示例使用\nFragment\t112\n4.6  Android widget 工具箱\t116\n4.7  创建新视图\t117\n4.7.1  修改现有的视图\t118\n4.7.2  创建复合控件\t122\n4.7.3  使用布局创建简单的复合\n控件\t124\n4.7.4  创建定制的视图\t124\n4.7.5  使用定制的控件\t137\n4.8  Adapter简介\t137\n4.8.1  部分原生Adapter简介\t138\n4.8.2  定制ArrayAdapter\t138\n4.8.3  使用Adapter绑定数据到\n视图\t139\n第5章  Intent和Broadcast Receiver\t145\n5.1  Intent简介\t145\n5.1.1  使用Intent来启动Activity\t146\n5.1.2  Linkify简介\t153\n5.1.3  使用Intent广播事件\t155\n5.1.4  Local Broadcast Manager\t159\n5.1.5  Pending Intent简介\t160\n5.2  创建Intent Filter和Broadcast\nReceiver\t161\n5.2.1  使用Intent Filter为隐式Intent\n提供服务\t161\n5.2.2  使用Intent Filter作为插件和\n扩展\t170\n5.2.3  监听本地Broadcast Intent\t173\n5.2.4  使用Broadcast Intent监控设备的\n状态变化\t174\n5.2.5  在运行时管理Manifest\nReceiver\t176\n第6章  使用Internet资源\t177\n6.1  下载和分析Internet资源\t177\n6.1.1  连接Internet资源\t178\n6.1.2  使用XML Pull Parser分析\nXML\t179\n6.1.3  创建一个地震查看器\t180\n6.2  使用Download Manager\t186\n6.2.1  下载文件\t186\n6.2.2  自定义Download Manager\nNotification\t187\n6.2.3  指定下载位置\t188\n6.2.4  取消和删除下载\t189\n6.2.5  查询Download Manager\t189\n6.3  使用Internet服务\t192\n6.4  连接到Google App Engine\t192\n6.5  下载数据而不会耗尽电量的\n最佳实践\t194\n第7章  文件、保存状态和首选项\t195\n7.1  保存简单的应用程序数据\t195\n7.2  创建并保存Shared Preference\t196\n7.3  检索Shared Preference\t197\n7.4  为地震查看器创建一个设置\nActivity\t197\n7.5  首选项框架和Preference Activity\n概述\t205\n7.5.1  在XML中定义一个\nPreference Screen布局\t206\n7.5.2  Preference Fragment简介\t208\n7.5.3  使用Preference Header定义\nPreference Fragment的层次\n结构\t208\n7.5.4  Preference Activity简介\t209\n7.5.5  向后兼容性与Preference\nScreen\t210\n7.5.6  找到并使用Preference Screen\n设置的Shared Preference\t210\n7.5.7  Shared Preference Change\nListener简介\t211\n7.6  为地震查看器创建一个标准的\nPreference Activity\t211\n7.7  持久化应用程序实例的状态\t215\n7.7.1  使用Shared Preference保存\nActivity状态\t215\n7.7.2  使用生命周期处理程序保存和\n还原Activity实例\t215\n7.7.3  使用生命周期处理程序保存和\n还原Fragment实例状态\t216\n7.8  将静态文件作为资源添加\t218\n7.9  在文件系统下工作\t218\n7.9.1  文件管理工具\t218\n7.9.2  使用特定于应用程序的文件夹\n存储文件\t219\n7.9.3  创建私有的应用程序文件\t219\n7.9.4  使用应用程序文件缓存\t220\n7.9.5  存储公共可读的文件\t220\n第8章  数据库和Content Provider\t223\n8.1  Android数据库简介\t223\n8.1.1  SQLite数据库简介\t224\n8.1.2  Content Provider简介\t224\n8.2  SQLite简介\t224\n8.3  Content Value和Cursor\t225\n8.4  使用SQLite数据库\t225\n8.4.1  SQLiteOpenHelper简介\t226\n8.4.2  在不使用SQLiteOpenHelper的\n情况下打开和创建数据库\t228\n8.4.3  Android数据库设计注意\n事项\t228\n8.4.4  查询数据库\t228\n8.4.5  从Cursor中提取值\t229\n8.4.6  添加、更新和删除行\t230\n8.5  创建Content Provider\t232\n8.5.1  注册Content Provider\t233\n8.5.2  发布Content Provider的URI\n地址\t233\n8.5.3  创建Content Provide的\n数据库\t234\n8.5.4  实现Content Provider查询\t235\n8.5.5  Content Provider事务\t236\n8.5.6  在Content Provider中存储\n文件\t239\n8.5.7  一个Content Provider的实现\n框架\t240\n8.6  使用Content Provider\t244\n8.6.1  Content Resolver简介\t244\n8.6.2  查询Content Provider\t244\n8.6.3  使用Cursor Loader异步查询\n内容\t247\n8.6.4  添加、删除和更新内容\t249\n8.6.5  访问Content Provider中存储的\n文件\t251\n8.6.6  创建一个To-Do List数据库和\nContent Provider\t253\n8.7  将搜索功能添加到应用程序中\t260\n8.7.1  使Content Provider可搜索\t261\n8.7.2  为应用程序创建一个搜索\nActivity\t261\n8.7.3  将搜索Activity设置为应用\n程序的默认搜索Provider\t263\n8.7.4  使用搜索视图微件\t266\n8.7.5  由Content Provider支持搜索\n建议\t267\n8.7.6  在快速搜索框中显示搜索\n结果\t270\n8.8  创建可搜索的地震Content\nProvider\t270\n8.8.1  创建Content Provider\t270\n8.8.2  使用地震Content Provider\t276\n8.8.3  搜索EarthquakeContent\nProvider\t279\n8.9  本地Android Content Provider\t285\n8.9.1  使用Media StoreContent\nProvider\t285\n8.9.2  使用Contacts Contract Content\nProvider\t286\n8.9.3  使用Calendar Content\nProvider\t293\n第9章  在后台操作\t297\n9.1  Service简介\t298\n9.1.1  创建和控制Service\t298\n9.1.2  将Service绑定到Activity\t302\n9.1.3  地震监控Service示例\t304\n9.1.4  创建前台Service\t308\n9.2  使用后台线程\t309\n9.2.1  使用AsyncTask运行异步任务\t310\n9.2.2  Intent Service简介\t312\n9.2.3  Loader简介\t313\n9.2.4  手动创建线程和GUI线程\n同步\t313\n9.3  使用Alarm\t315\n9.3.1  创建、设置和取消Alarm\t316\n9.3.2  设置重复Alarm\t317\n9.3.3  使用重复Alarm调度网络\n刷新\t318\n9.4  使用Intent Service简化Earthquake\n更新Service\t320\n第10章  扩展用户体验\t323\n10.1  操作栏简介\t324\n10.1.1  自定义操作栏\t325\n10.1.2  自定义操作栏来控制应用\n程序的导航行为\t328\n10.1.3  操作栏操作简介\t333\n10.2  向地震监控程序添加一个\n操作栏\t333\n10.3  创建并使用菜单和操作栏\n操作项\t339\n10.3.1  Android菜单系统简介\t340\n10.3.2  创建菜单\t341\n10.3.3  指定操作栏的操作\t342\n10.3.4  菜单项选项\t343\n10.3.5  添加操作View和操作提供\n程序\t344\n10.3.6  在Fragment中添加菜单项\t345\n10.3.7  使用XML定义菜单层次\n结构\t345\n10.3.8  动态更新菜单项\t347\n10.3.9  处理菜单选择\t347\n10.3.10  子菜单和上下文菜单简介\t348\n10.4  更新地震监控程序\t351\n10.5  全屏显示\t353\n10.6  对话框简介\t355\n10.6.1  创建一个对话框\t356\n10.6.2  使用AlertDialog类\t356\n10.6.3  使用专门的输入对话框\t357\n10.6.4  通过Dialog Fragment管理和\n显示对话框\t358\n10.6.5  通过Activity事件处理程序\n管理和显示对话框\t360\n10.6.6  将Activity用作对话框\t361\n10.7  创建Toast\t361\n10.7.1  自定义Toast\t362\n10.7.2  在工作线程中使用Toast\t364\n10.8  Notification简介\t365\n10.8.1  Notification Manager简介\t366\n10.8.2  创建Notification\t366\n10.8.3  设置和自定义通知托盘UI\t369\n10.8.4  配置持续和连续的\nNotification\t373\n10.8.5  触发、更新和取消\nNotification\t374\n10.9  向地震监控程序中添加\nNotification和对话框\t376\n第11章  高级用户体验\t381\n11.1  为每个屏幕尺寸和分辨率做\n设计\t382\n11.1.1  分辨率无关\t382\n11.1.2  为不同的屏幕大小提供支持和\n优化\t383\n11.1.3  创建可缩放的图形资源\t386\n11.1.4  创建优化的、自适应的、\n动态的设计\t390\n11.1.5  反复测试\t390\n11.2  确保可访问性\t391\n11.2.1  为非触屏设备提供导航\t391\n11.2.2  为每个View提供文本\n描述\t391\n11.3  Android Text-to-Speech简介\t392\n11.4  使用语音识别\t394\n11.4.1  使用语音识别进行语音\n输入\t395\n11.4.2  使用语音识别进行搜索\t396\n11.5  控制设备振动\t396\n11.6  使用动画\t397\n11.6.1  补间View动画\t397\n11.6.2  创建和使用逐帧动画\t400\n11.6.3  插值属性动画\t400\n11.7  强化View\t404\n11.7.1  高级Canvas绘图\t404\n11.7.2  硬件加速\t419\n11.7.3  Surface View简介\t420\n11.7.4  创建交互式控件\t423\n11.8  高级Drawable资源\t428\n11.9  复制、粘贴和剪贴板\t431\n11.9.1  向剪贴板中复制数据\t431\n11.9.2  粘贴剪贴板数据\t431\n第12章  硬件传感器\t433\n12.1  使用传感器和传感器\n管理器\t433\n12.1.1  受支持的Android传感器\t434\n12.1.2  虚拟传感器简介\t435\n12.1.3  查找传感器\t435\n12.1.4  监视传感器\t436\n12.1.5  解释传感器值\t438\n12.2  监视设备的移动和方向\t439\n12.2.1  确定设备的自然方向\t440\n12.2.2  加速计简介\t441\n12.2.3  检测加速度变化\t442\n12.2.4  创建一个重力计\t443\n12.2.5  确定设备方向\t446\n12.2.6  创建一个指南针和人工\n地平仪\t450\n12.2.7  陀螺仪传感器简介\t453\n12.3  环境传感器简介\t454\n12.3.1  使用气压计传感器\t454\n12.3.2  创建气象站\t455\n第13章  地图、地理编码和基于位置的\n服务\t461\n13.1  使用基于位置的服务\t461\n13.2  在模拟器中使用基于位置的\n服务\t462\n13.2.1  更新模拟器位置提供器中的\n位置\t463\n13.2.2  配置模拟器来测试基于位置的\n服务\t463\n13.3  选择一个位置提供器\t464\n13.3.1  查找位置提供器\t464\n13.3.2  通过指定条件查找位置\n提供器\t464\n13.3.3  确定位置提供器的能力\t465\n13.4  确定当前位置\t466\n13.4.1  位置的隐私性\t466\n13.4.2  找出上一次确定的位置\t466\n13.4.3  Where Am I示例\t466\n13.4.4  刷新当前位置\t469\n13.4.5  在Where Am I中跟踪\n位置\t472\n13.4.6  请求单独一次位置更新\t473\n13.5  位置更新的最佳实践\t474\n13.6  使用近距离提醒\t477\n13.7  使用地理编码器\t478\n13.7.1  反向地理编码\t479\n13.7.2  前向地理编码\t480\n13.7.3  对\u201cWhere Am I\u201d示例\n进行地理编码\t481\n13.8  创建基于地图的Activity\t482\n13.8.1  MapView和MapActivity\n简介\t482\n13.8.2  获得地图的API key\t483\n13.8.3  创建一个基于地图的\nActivity\t483\n13.8.4  地图和Fragment\t485\n13.8.5  配置和使用MapView\t486\n13.8.6  使用MapController\t486\n13.8.7  对\u201cWhere Am I\u201d示例使用\n地图\t487\n13.8.8  创建和使用覆盖(Overlay)\t490\n13.8.9  MyLocationOverlay简介\t497\n13.8.10  ItemizedOverlay和\nOverlayItem简介\t498\n13.8.11  将视图固定到地图和地图的\n某个位置上\t500\n13.9  对Earthquake示例添加地图\n功能\t501\n第14章  个性化主屏幕\t507\n14.1  主屏幕Widget简介\t507\n14.2  创建App Widgets\t509\n14.2.1  创建Widget的XML\n布局资源\t509\n14.2.2  定义Widget设置\t511\n14.2.3  创建Widget Broadcast Receiver\n并将其添加到应用程序的\nmanifest文件中\t512\n14.2.4  AppWidgetManager和\nRemoteView简介\t513\n14.2.5  刷新Widget\t518\n14.2.6  创建并使用Widget配置\nActivity\t521\n14.3  创建地震Widget\t522\n14.4  Collection View Widget简介\t528\n14.4.1  创建Collection View Widget的\n布局\t529\n14.4.2  创建RemoteViewsService\t530\n14.4.3  创建一个RemoteViews-\nFactory\t531\n14.4.4  使用RemoteViewsService\n填充CollectionViewWidget\t533\n14.4.5  向Collection View Widget\n中的项添加交互性\t534\n14.4.6  将Collection View Widget\n绑定到Content Provider\t535\n14.4.7  刷新Collection View\nWidget\t537\n14.4.8  创建Earthquake Collection\nView Widget\t537\n14.5  Live Folder简介\t543\n14.5.1  创建Live Folder\t544\n14.5.2  创建Earthquake Live Folder\t548\n14.6  使用快速搜索框显示应用程序\n搜索结果\t551\n14.6.1  在快速搜索框中显示搜索\n结果\t551\n14.6.2  将Earthquake示例的搜索\n结果添加到快速搜索框中\t552\n14.7  创建Live Wallpaper\t553\n14.7.1  创建Live Wallpaper定义\n资源\t553\n14.7.2  创建Wallpaper Service\t554\n14.7.3  创建Wallpaper Service\n引擎\t555\n第15章  音频、视频以及摄像头的\n使用\t557\n15.1  播放音频和视频\t558\n15.1.1  Media Player简介\t559\n15.1.2  准备音频播放\t559\n15.1.3  准备视频播放\t560\n15.1.4  控制Media Player的\n播放\t564\n15.1.5  管理媒体播放输出\t566\n15.1.6  响应音量控制\t566\n15.1.7  响应Media播放控件\t567\n15.1.8  请求和管理音频焦点\t569\n15.1.9  当音频输出改变时暂停\n播放\t571\n15.1.10  Remote Control Client简介\t572\n15.2  操作原始音频\t574\n15.2.1  使用AudioRecord录制\n声音\t574\n15.2.2  使用AudioTrack播放音频\t575\n15.3  创建一个Sound Pool\t577\n15.4  使用音效\t578\n15.5  使用摄像头拍摄照片\t579\n15.5.1  使用Intent拍摄照片\t579\n15.5.2  直接控制摄像头\t581\n15.5.3  读取并写入 JPEG EXIF图像\n详细信息\t588\n15.6  录制视频\t589\n15.6.1  使用Intent录制视频\t589\n15.6.2  使用MediaRecorder录制\n视频\t590\n15.7  使用媒体效果\t593\n15.8  向媒体库中添加新媒体\t594\n15.8.1  使用媒体扫描仪插入媒体\t594\n15.8.2  手动插入媒体\t595\n第16章  蓝牙、NFC、网络和Wi-Fi\t597\n16.1  使用蓝牙\t597\n16.1.1  管理本地蓝牙设备适配器\t598\n16.1.2  可发现性和远程设备发现\t600\n16.1.3  蓝牙通信\t604\n16.2  管理网络和Internet连接\t609\n16.2.1  Connectivity Manager简介\t609\n16.2.2  支持用户首选项以进行后台\n数据传输\t609\n16.2.3  查找和监视网络连接\t611\n16.3  管理Wi-Fi\t612\n16.3.1  监视Wi-Fi连接\t613\n16.3.2  监视活动的Wi-Fi连接的\n详细信息\t613\n16.3.3  扫描热点\t613\n16.3.4  管理Wi-Fi配置\t614\n16.3.5  创建Wi-Fi网络配置\t615\n16.4  使用Wi-Fi Direct传输数据\t615\n16.4.1  初始化Wi-Fi Direct框架\t615\n16.4.2  启用Wi-Fi Direct并监视其\n状态\t617\n16.4.3  发现对等设备\t618\n16.4.4  连接对等设备\t618\n16.4.5  在对等设备之间传输数据\t620\n16.5  近场通信\t621\n16.5.1  读取NFC标签\t622\n16.5.2  使用前台分派系统\t623\n16.5.3  Android Beam简介\t625\n第17章  电话服务和SMS\t629\n17.1  电话服务的硬件支持\t629\n17.1.1  将电话功能指定为必需的\n硬件功能\t629\n17.1.2  检查电话硬件\t630\n17.2  使用电话服务\t630\n17.2.1  启动电话呼叫\t630\n17.2.2  替换本机拨号程序\t631\n17.2.3  访问电话服务的属性及状态\t632\n17.2.4  使用PhoneStateListener\n监视电话状态的变化\t635\n17.2.5  使用Intent Receiver监视传入的\n电话呼叫\t639\n17.3  SMS和MMS简介\t640\n17.3.1  在应用程序中使用SMS和\nMMS\t640\n17.3.2  使用Intent从应用程序中\n发送SMS和MMS\t640\n17.3.3  使用SMS Manager发送\nSMS消息\t641\n17.3.4  监听传入的SMS消息\t644\n17.3.5  紧急响应程序SMS示例\t646\n17.3.6  自动紧急响应程序\t654\n17.4  SIP和VOIP简介\t662\n第18章  Android高级开发\t663\n18.1  Android的安全性\t664\n18.1.1  Linux内核安全\t664\n18.1.2  权限简介\t664\n18.2  Cloud to Device Messaging简介\t666\n18.2.1  C2DM的局限性\t667\n18.2.2  注册使用C2DM\t667\n18.2.3  在C2DM服务器上注册\n设备\t667\n18.2.4  向设备发送C2DM消息\t670\n18.2.5  接收C2DM消息\t672\n18.3  使用License Verification Library\n实现版权保护\t673\n18.3.1  安装License Verification\nLibrary\t673\n18.3.2  获得License Verification\n公钥\t673\n18.3.3  配置License Validation\nPolicy\t674\n18.3.4  执行许可验证检查\t674\n18.4  应用程序内收费\t675\n18.4.1  应用程序内收费的局限性\t676\n18.4.2  安装IAB库\t676\n18.4.3  获得公钥和定义可购买的\n物品\t676\n18.4.4  开始IAB交易\t677\n18.4.5  处理IAB购买请求的响应\t678\n18.5  使用Wake Lock\t679\n18.6  使用AIDL支持Service的\nIPC\t680\n18.7  处理不同硬件和软件的可用性\t686\n18.7.1  指定硬件的要求\t686\n18.7.2  确认硬件可用性\t687\n18.7.3  构建向后兼容的应用程序\t687\n18.8  利用STRICT模式优化UI\n性能\t689\n第19章  推广和发布应用程序并从中\n获利\t691\n19.1  签名和发布应用程序\t691\n19.2  发布应用程序\t693\n19.2.1  Google Play简介\t693\n19.2.2  开始使用Google Play\t694\n19.2.3  发布应用程序\t695\n19.2.4  开发者控制台上的应用程序\n报告\t697\n19.2.5  查看应用程序错误报告\t697\n19.3  如何通过应用程序赚钱\t698\n19.4  应用程序销售、推广和分发的\n策略\t699\n19.4.1  应用程序的起步策略\t699\n19.4.2  在Google Play上推广\t700\n19.4.3  国际化\t700\n19.5  分析数据和跟踪推荐人\t701\n19.5.1  使用移动应用程序的Google\nAnalytics\t702\n19.5.2  使用Google Analytics追踪\n推荐\t703","pages":"703","images":{"small":"https://img1.doubanio.com/spic/s26343747.jpg","large":"https://img1.doubanio.com/lpic/s26343747.jpg","medium":"https://img1.doubanio.com/mpic/s26343747.jpg"},"alt":"https://book.douban.com/subject/24153574/","id":"24153574","publisher":"清华大学出版社","isbn10":"7302315582","isbn13":"9787302315582","title":"Android 4高级编程","url":"https://api.douban.com/v2/book/24153574","alt_title":"Professional Android 4 Application Development","author_intro":"Reto Meier 目前是Google Android 团队的一名Android 开发人员倡导者，帮助Android 开发人员创建最优秀的应用程序。Reto 是一位经验丰富的软件开发人员，拥有逾10 年的GUI 应用程序开发经验。进入Google 之前，他曾在多种行业中工作过，包括海洋石油、天然气以及金融业。\nReto 始终不渝地追求掌握新技术，从2007 年Android 发布之初Reto 就迷恋上了此项技术。在Reto 的个人网站Radioactive Yak(http://blog. radioactiveyak.com) 上可以了解Reto 的兴趣和爱好。他还在Google+(http://profiles.google.com/reto.meier) 和Twitter(www.twitter.com/retomeier) 上分享各种信息。\n技术编辑简介\nDan Ulery 是一名软件工程师，具有.NET、Java 和PHP 的开发经验，并且十分熟悉软件部署。他毕业于爱达荷大学，获得了计算机科学学士学位，并且辅修了数学专业。","summary":"《Android 4高级编程(第3版)》由Android权威专家编写，涵盖了所有最新的内容，是学习使用Android 4 SDK开发移动应用程序的理想指南。本书见解深刻，帮助经验丰富的Android开发人员充分挖掘Android 4的新特性的潜力，同时讲解了Android开发的基础知识，使初学者也可以借助本书入门。作为一本以实用性为目的的指导图书，本书带领您逐步完成复杂程度越来越高的Android项目，每个项目中都引入一种新的Android平台特性，并着重指出有助于编写引人入胜的应用程序的技术和最佳实践。\n本书特色\n◆ 深入分析了Android应用程序的组件和生命周期\n◆ 探讨了Android的UI原理、设计理念和UI API，使用户界\n面在手机、平板电脑和电视上都引人注目\n◆ 介绍了创建基于地图的应用程序和使用基于位置的服务\n的相关知识\n◆ 解释了如何创建后台服务、通知和Cloud to Device Messaging\n◆ 演示了如何创建动态的、交互式的主屏幕微件和Live\nWallpaper\n◆ 探索了硬件和通信API，包括蓝牙、电话、Wi-Fi Direct、\nNFC和Android Beam\n◆ 讲解了摄像头和硬件传感器的使用\n◆ 详述了新的动画框架和其他增强用户体验的特性，包括\n拖放、Action Bar和Fragment\n◆ 新增了关于应用程序发布的一章内容\n◆ 介绍了License Verification和应用程序内收费服务","price":"98.00元"},{"rating":{"max":10,"numRaters":59,"average":"7.6","min":0},"subtitle":"Android与 iOS应用测试指南","author":["陈晔"],"pubdate":"2014-7-7","tags":[{"count":76,"name":"软件测试","title":"软件测试"},{"count":69,"name":"移动测试","title":"移动测试"},{"count":31,"name":"测试","title":"测试"},{"count":23,"name":"互联网","title":"互联网"},{"count":19,"name":"大话移动APP测试：Android与","title":"大话移动APP测试：Android与"},{"count":14,"name":"IT","title":"IT"},{"count":14,"name":"Android","title":"Android"},{"count":13,"name":"移动","title":"移动"}],"origin_title":"","image":"https://img1.doubanio.com/mpic/s27635237.jpg","binding":"平装","translator":[],"catalog":"《大话移动app测试：android与 ios应用测试指南》\n第1章 移动互联网面试 1\n1.1 为什么要面试 2\n1.2 面试的流程 2\n1.3 面试的频率 3\n1.4 面试实战 3\n1.5 如何正确地招聘测试人员 8\n1.6 移动互联网测试招聘现状 12\n1.7 大公司和小公司 13\n1.7.1 故事一 14\n1.7.2 故事二 15\n1.8 测试外包 16\n1.9 小结 17\n第2章 病态的现状 19\n2.1 全民挖金 20\n2.2 别人的嫁衣 22\n2.2.1 talkbox 23\n2.2.2 米聊 23\n2.2.3 飞信 24\n2.3 超越光速的迭代 25\n2.4 可怜的测试团队 27\n2.5 敏捷中毒 28\n2.6 无力的测试 29\n2.7 浮躁的测试工程师们 31\n2.7.1 社交中毒 31\n2.7.2 失去自理能力 32\n2.7.3 不能正确认识自己的价值 33\n2.8 测试沙龙和培训 34\n2.9 学会自我尊重 35\n2.10 小结 36\n第3章 用户体验测试 37\n3.1 移动互联网与传统互联网体验上的区别 38\n3.1.1 区别一\u2014\u2014用户关注点 38\n3.1.2 区别二\u2014\u2014场合复杂化 39\n3.1.3 区别三\u2014\u2014时间碎片化 39\n3.1.4 区别四\u2014\u2014输入困难化 39\n3.2 android vs ios 40\n3.2.1 桌面 40\n3.2.2 联系人 41\n3.2.3 短信 43\n3.2.4 历史应用 43\n3.2.5 相册 44\n3.2.6 其他 46\n3.3 \u201c愚笨\u201d的用户\u2014\u2014用户引导 47\n3.4 \u201c捣乱\u201d的用户\u2014\u2014应用容错 52\n3.4.1 注册与登录 52\n3.4.2 断网引发的问题 54\n3.5 专业精神\u2014\u2014风格一致性 57\n3.5.1 应用与系统风格一致 58\n3.5.2 应用本身风格一致 59\n3.6 \u201c我\u201d即最终用户：过程体验测试 60\n3.7 使用更多的应用：对比体验测试 65\n3.8 模拟场景体验测试 66\n3.8.1 应用一：智能手机输入法 67\n3.8.2 应用二：智能机顶盒 68\n3.9 用户究竟关心什么？ 69\n3.9.1 用户只关心应用能在自己手机上正常运行 69\n3.9.2 用户隐私权限 70\n3.9.3 简洁、方便 71\n3.9.4 消耗 71\n3.9.5 好不好用 72\n3.10 用户体验的问题是bug吗？ 72\n3.11 如何提升自身的用户体验经验？ 73\n3.12 小结 74\n第4章 功能测试要点 75\n4.1 多分辨率测试 76\n4.2 多系统测试 77\n4.3 用户不同的使用习惯 80\n4.3.1 android权限问题 80\n4.3.2 android硬件问题 81\n4.3.3 android操作习惯 83\n4.3.4 android数据的移动或清空 84\n4.3.5 ios操作习惯 85\n4.3.6 ios越狱问题 86\n4.4 网络的不稳定性 88\n4.5 安装/卸载测试 92\n4.6 升级测试 94\n4.6.1 增量升级 95\n4.6.2 内置应用升级 96\n4.7 并发测试 96\n4.7.1 弹出框提示 96\n4.7.2 另一个应用启动 97\n4.7.3 关机或待机 98\n4.7.4 功能冲突 98\n4.7.5 可存储设备 98\n4.8 数据来源 98\n4.9 推送 100\n4.10 分享跳转 102\n4.11 小结 104\n第5章 常用工具介绍和实践 105\n5.1 monkey 106\n5.1.1 第一个简单的monkey测试命令 106\n5.1.2 monkey测试工具实例 107\n5.1.3 monkey测试日志查看 108\n5.1.4 monkey测试注意点 112\n5.1.5 monkey工具再探索 114\n5.2 emulator 115\n5.2.1 模拟器和真机的差异 115\n5.2.2 genymotion 118\n5.2.3 模拟器常用功能举例 119\n5.3 monkeyrunner 121\n5.4 hierarchy viewer 126\n5.5 ddms 129\n5.6 compatibility test suite 133\n5.7 tcpdump/wireshark 136\n5.8 findbugs 138\n5.9 lint 140\n5.10 反编译、重编译 142\n5.11 ant 146\n5.12 charles 148\n5.13 instruments 150\n5.14 小结 153\n第6章 常用框架介绍和实践 155\n6.1 instrumentation 156\n6.1.1 技巧一 158\n6.1.2 技巧三 160\n6.1.3 技巧三 161\n6.2 emma code coverage 163\n6.3 robolectric 173\n6.4 小结 185\n第7章 移动应用测试案例实践分析 187\n7.1 深入了解被测试对象 188\n7.2 多种数据来源 190\n7.3 在生活中使用产品 193\n7.4 社交应用分层设计实践案例 195\n7.5 联系人搜索案例测试设计实践 204\n7.6 小结 212\n第8章 性能测试介绍和实践 215\n8.1 emmagee 216\n8.2 instrumentation 217\n8.3 hprof 220\n8.4 gfxinfo 223\n8.5 systrace 225\n8.6 traceview 226\n8.7 instruments\u2014\u2014leaks 229\n8.8 android多分辨率自动化实践 233\n8.9 小结 239\n附录a 测试人员的自我修养（吐槽篇） 241\na.1 学会提出和解决问题 242\na.2 正确地自我审视 243\na.3 不要被业界世俗的讨论蒙蔽 245\na.4 寻找测试的本质 247\na.5 主观能动 248\na.6 你真的会使用搜索引擎吗 250\na.7 每天都要学习 252\na.8 学会判断轻重缓急 254\na.9 小结 254\n附录b 测试行业常见问题（q&a篇） 255\nq1：没有做过测试的人怎么入门？ 256\nq2：测试工程师要具备什么能力？ 257\nq3：测试比开发技术含量低吗？ 258\nq4：参加测试培训能有多少提升？ 259\nq5：黑盒测试有价值吗？ 260\nq6：手动测试有价值吗？ 261\nq7：怎么做移动互联网应用的自动化测试？ 261\nq8：测试人员选择进入大公司还是小公司？ 263\nq9：中国高校有软件测试专业吗？ 264\nq10：小结 266\n附录c 博客摘录 267\nc.1 我们需要专职的qa吗？ 268\nc.2 学习让测试更精彩，测试让生命更精彩 271\nc.3 中国人的纠结 278\nc.4 黑盒不是白盒的绊脚石 283\nc.5 测试需要反省 283\nc.6 《钝感力》有感\u2014\u2014测试中的钝感力 286\n后记 289","ebook_url":"https://read.douban.com/ebook/25702244/","pages":"292","images":{"small":"https://img1.doubanio.com/spic/s27635237.jpg","large":"https://img1.doubanio.com/lpic/s27635237.jpg","medium":"https://img1.doubanio.com/mpic/s27635237.jpg"},"alt":"https://book.douban.com/subject/25923638/","id":"25923638","publisher":"清华大学出版社","isbn10":"7302368791","isbn13":"9787302368793","title":"大话移动APP测试：Android与 iOS应用测试指南","url":"https://api.douban.com/v2/book/25923638","alt_title":"","author_intro":"","summary":"","ebook_price":"35.40","price":"CNY 59.00"},{"rating":{"max":10,"numRaters":204,"average":"8.5","min":0},"subtitle":"","author":["[美] Bill Phillips","[美] Brian Hardy"],"pubdate":"2014-4","tags":[{"count":234,"name":"Android","title":"Android"},{"count":119,"name":"android","title":"android"},{"count":90,"name":"编程","title":"编程"},{"count":61,"name":"移动开发","title":"移动开发"},{"count":53,"name":"计算机","title":"计算机"},{"count":39,"name":"软件开发","title":"软件开发"},{"count":28,"name":"程序设计","title":"程序设计"},{"count":15,"name":"移动互联网","title":"移动互联网"}],"origin_title":"Android programming: the big nerd ranch guide","image":"https://img3.doubanio.com/mpic/s28342615.jpg","binding":"平装","translator":["王明发"],"catalog":"第1章　Android应用初体验　　1\n1.1 　应用基础　　2\n1.2 　创建Android项目　　2\n1.3 　Eclipse工作区导航　　5\n1.4 　用户界面设计　　6\n1.4.1 　视图层级结构　　9\n1.4.2 　组件属性　　10\n1.4.3 　创建字符串资源　　11\n1.4.4 　预览界面布局　　12\n1.5 　从布局XML到视图对象　　13\n1.6 　组件的实际应用　　15\n1.6.1 　类包组织导入　　16\n1.6.2 　引用组件　　16\n1.6.3 　设置监听器　　17\n1.7 　使用模拟器运行应用　　21\n1.8 　Android编译过程　　22\n第2章　Android与MVC设计模式　　26\n2.1 　创建新类　　26\n2.2 　Android与MVC设计模式　　30\n2.3 　更新视图层　　31\n2.4 　更新控制层　　33\n2.5 　在设备上运行应用　　37\n2.5.1 　连接设备　　37\n2.5.2 　配置设备用于应用开发　　38\n2.6 　添加图标资源　　38\n2.6.1 　向项目中添加资源　　39\n2.6.2 　在XML文件中引用资源　　40\n2.7 　关于挑战练习　　41\n2.8 　挑战练习一：为TextView添加监听器　　41\n2.9 　挑战练习二：添加后退按钮　　42\n2.10 　挑战练习三：从按钮到图标按钮　　42\n第3章　Activity的生命周期　　45\n3.1 　日志跟踪理解Activity生命周期　　46\n3.1.1 　输出日志信息　　46\n3.1.2 　使用 LogCat　　48\n3.2 　设备旋转与Activity生命周期　　52\n3.3 　设备旋转前保存数据　　56\n3.4 　再探Activity生命周期　　57\n3.5 　深入学习：测试onSaveInstanceState-(Bundle)方法　　59\n3.6 　深入学习：日志记录的级别与方法　　60\n第4章　Android应用的调试　　62\n4.1 　DDMS应用调试透视图　　63\n4.2 　异常与栈跟踪　　64\n4.2.1 　诊断应用异常　　65\n4.2.2 　记录栈跟踪日志　　66\n4.2.3 　设置断点　　68\n4.2.4 　使用异常断点　　71\n4.3 　文件浏览器　　72\n4.4 　Android特有的调试工具　　73\n4.4.1 　使用Android Lint　　73\n4.4.2 　R类的问题　　74\n第5章　第二个activity　　75\n5.1 　创建第二个activity　　76\n5.1.1 　创建新布局　　77\n5.1.2 　创建新的activity子类　　80\n5.1.3 　在manifest配置文件中声明activity　　81\n5.1.4 　为QuizActivity添加cheat按钮　　82\n5.2 　启动activity　　83\n5.3 　activity间的数据传递　　85\n5.3.1 　使用intent extra　　86\n5.3.2 　从子activity获取返回结果　　88\n5.4 　activity的使用与管理　　92\n5.5 　挑战练习　　95\n第6章　Android SDK版本与兼容　　96\n6.1 　Android SDK版本　　96\n6.2 　Android编程与兼容性问题　　97\n6.2.1 　全新的系统版本\u2014\u2014Honeycomb　　97\n6.2.2 　SDK最低版本　　99\n6.2.3 　SDK目标版本　　99\n6.2.4 　SDK编译版本　　99\n6.2.5 　安全添加新版本API中的代码　　100\n6.3 　使用Android开发者文档　　103\n6.4 　挑战练习：报告编译版本　　105\n第7章　UI fragment与fragment 管理器　　106\n7.1 　UI设计的灵活性需求　　107\n7.2 　fragment的引入　　107\n7.3 　着手开发CriminalIntent　　108\n7.3.1 　创建新项目　　110\n7.3.2 　fragment与支持库　　112\n7.3.3 　创建Crime类　　113\n7.4 　托管UI fragment　　115\n7.4.1 　fragment的生命周期　　115\n7.4.2 　托管的两种方式　　116\n7.4.3 　定义容器视图　　116\n7.5 　创建UI fragment　　117\n7.5.1 　定义CrimeFragment的布局　　118\n7.5.2 　创建CrimeFragment类　　119\n7.6 　添加UI fragment到FragmentManager　　122\n7.6.1 　fragment事务　　123\n7.6.2 　FragmentManager与fragment生命周期　　125\n7.7 　activity使用fragment的理由　　127\n7.8 　深入学习：Honeycomb、ICS、Jelly Bean以及更高版本系统上的应用开发　　127\n第8章　使用布局与组件创建用户界面　　128\n8.1 　升级Crime类　　128\n8.2 　更新布局　　129\n8.3 　生成并使用组件　　131\n8.4 　深入探讨XML布局属性　　132\n8.4.1 　样式、主题及主题属性　　132\n8.4.2 　dp、sp以及屏幕像素密度　　133\n8.4.3 　Android开发设计原则　　134\n8.4.4 　布局参数　　135\n8.4.5 　边距与内边距　　135\n8.5 　使用图形布局工具　　136\n8.5.1 　添加新组件　　138\n8.5.2 　属性视图中编辑组件属性　　138\n8.5.3 　在框架视图中重新组织组件　　139\n8.5.4 　更新子组件的布局参数　　140\n8.5.5　　android:layout_weight属性的工作原理　　141\n8.5.6 　图形布局工具使用总结　　142\n8.5.7 　组件ID与多种布局　　142\n8.6 　挑战练习：日期格式化　　143\n第9章　使用ListFragment显示列表　　144\n9.1 　更新CriminalIntent应用的模型层　　145\n9.2 　创建ListFragment　　147\n9.3 　使用抽象activity托管fragment　　149\n9.3.1 　通用的fragment托管布局　　149\n9.3.2 　抽象activity类　　150\n9.4 　ListFragment、ListView及ArrayAdapter　　154\n9.4.1 　创建ArrayAdapter<T>类实例　　157\n9.4.2 　响应列表项的点击事件　　159\n9.5 　定制列表项　　160\n9.5.1 　创建列表项布局　　160\n9.5.2 　创建adapter子类　　162\n第10章　使用fragment argument　　165\n10.1 　从fragment中启动activity　　165\n10.1.1 　附加extra信息　　166\n10.1.2 　获取extra信息　　167\n10.1.3 　使用Crime数据更新CrimeFragment视图　　167\n10.1.4 　直接获取extra信息方式的缺点　　169\n10.2 　fragment argument　　169\n10.2.1 　附加argument给fragment　　169\n10.2.2 　获取argument　　170\n10.3 　重新加载显示列表项　　171\n10.4 　通过fragment获取返回结果　　172\n第11章　使用ViewPager　　174\n11.1 　创建CrimePagerActivity　　175\n11.1.1 　以代码的方式定义并产生布局　　176\n11.1.2 　ViewPager与Pager-Adapter　　177\n11.1.3 　整合配置并使用CrimePagerActivity　　178\n11.1.4 　FragmentStatePager-Adapter与Fragment-PagerAdapter　　180\n11.2 　深入学习：ViewPager的工作原理　　182\n第12章　对话框　　184\n12.1 　创建DialogFragment　　186\n12.1.1 　显示DialogFragment　　187\n12.1.2 　设置对话框的显示内容　　188\n12.2 　fragment间的数据传递　　190\n12.2.1 　传递数据给DatePicker-Fragment　　191\n12.2.2 　返回数据给CrimeFragment　　193\n12.3 　挑战练习：更多对话框　　198\n第13章　使用MediaPlayer播放音频　　199\n13.1 　添加资源　　200\n13.2 　定义HelloMoonFragment布局文件　　202\n13.3 　创建HelloMoonFragment　　203\n13.4 　使用布局fragment　　204\n13.5 　音频播放　　205\n13.6 　挑战练习：暂停音频播放　　208\n13.7 　深入学习：播放视频　　208\n13.8 　挑战练习：在HelloMoon应用中播放视频　　208\n第14章　fragment的保留　　209\n14.1 　保留fragment实例　　209\n14.2 　设备旋转与保留的fragment　　210\n14.3 　保留的fragment：一切都完美了吗　　212\n14.4 　设备旋转处理与onSaveInstance-State(Bundle)方法　　212\n14.5 　深入学习：fragment引入前的设备旋转问题　　214\n第15章　应用本地化　　215\n15.1 　本地化资源　　215\n15.2 　配置修饰符　　216\n15.2.1 　可用资源优先级排定　　217\n15.2.2 　多重配置修饰符　　218\n15.2.3 　寻找最匹配的资源　　219\n15.3 　更多资源使用原则及控制　　220\n15.3.1 　资源命名　　220\n15.3.2 　资源目录结构　　220\n15.4 　测试备选资源　　221\n第16章　操作栏　　223\n16.1 　选项菜单　　223\n16.1.1 　在XML文件中定义选项菜单　　225\n16.1.2 　创建选项菜单　　227\n16.1.3 　响应菜单项选择　　230\n16.2 　实现层级式导航　　232\n16.2.1 　启用应用图标的导航功能　　232\n16.2.2 　响应向上按钮　　233\n16.3 　可选菜单项　　236\n16.3.1 　创建可选菜单XML文件　　236\n16.3.2 　切换菜单项标题　　237\n16.3.3 　\u201c还有个问题\u201d　　238\n16.4 　挑战练习：用于列表的空视图　　239\n第17章　存储与加载本地文件　　241\n17.1 　CriminalIntent应用的数据存取　　241\n17.1.1 　保存crime数据到JSON文件　　242\n17.1.2 　从文件中读取crime数据　　246\n17.2 　挑战练习：使用外部存储　　248\n17.3 　深入学习：Android文件系统与Java I/O　　248\n第18章　上下文菜单与上下文操作模式　　250\n18.1 　定义上下文菜单资源　　251\n18.2 　实施浮动上下文菜单　　251\n18.2.1 　创建上下文菜单　　251\n18.2.2 　为上下文菜单登记视图　　252\n18.2.3 　响应菜单项选择　　253\n18.3 　实施上下文操作模式　　254\n18.3.1 　实现列表视图的多选操作　　255\n18.3.2 　列表视图中的操作模式回调方法　　256\n18.3.3 　改变已激活视图的显示背景　　258\n18.3.4 　实现其他视图的上下文操作模式　　259\n18.4 　兼容性问题：回退还是复制　　260\n18.5 　挑战练习：在CrimeFragment视图中删除crime记录　　261\n18.6 　深入学习：ActionBarSherlock　　261\n18.7 　挑战练习：使用ActionBarSherlock　　263\n18.7.1 　CriminalIntent应用中ABS的基本整合　　264\n18.7.2 　ABS的深度整合　　264\n18.7.3 　ABS的完全整合　　265\n第19章　相机I：取景器　　266\n19.1 　创建Fragment布局　　267\n19.2 　创建CrimeCameraFragment　　269\n19.3 　创建CrimeCameraActivity　　269\n19.4 　使用相机API　　271\n19.4.1 　打开并释放相机　　271\n19.4.2 　SurfaceView、Surface-Holder与Surface　　272\n19.4.3 　确定预览界面大小　　276\n19.4.4 　启动CrimeCamera-Activity　　277\n19.5 　深入学习：以命令行的方式运行activity　　281\n第20章　相机 II：拍摄并处理照片　　283\n20.1 　拍摄照片　　283\n20.1.1 　实现相机回调方法　　285\n20.1.2 　设置图片尺寸大小　　288\n20.2 　返回数据给CrimeFragment　　288\n20.2.1 　以接收返回值的方式启动CrimeCameraActivity　　289\n20.2.2 　在CrimeCameraFragment中设置返回值　　290\n20.2.3 　在CrimeFragment中获取照片文件名　　290\n20.3 　更新模型层　　291\n20.3.1 　新增Photo类　　292\n20.3.2 　为Crime添加photo属性　　293\n20.3.3 　设置photo属性　　293\n20.4 　更新CrimeFragment的视图　　294\n20.4.1 　添加ImageView组件　　295\n20.4.2 　图像处理　　296\n20.5 　在DialogFragment中显示大图片　　300\n20.6 　挑战练习：Crime照片的显示方向　　303\n20.7 　挑战练习：删除照片　　303\n20.8 　深入学习：Android代码的废弃处理　　303\n第21章　隐式intent　　305\n21.1 　添加按钮组件　　306\n21.2 　添加嫌疑人信息至模型层　　307\n21.3 　使用格式化字符串　　308\n21.4 　使用隐式intent　　309\n21.4.1 　典型隐式intent的组成　　310\n21.4.2 　发送陋习报告　　311\n21.4.3 　获取联系人信息　　313\n21.4.4 　检查可以响应的activity　　316\n21.5 　挑战练习：又一个隐式intent　　317\n第22章　Master-Detail用户界面　　318\n22.1 　增加布局灵活性　　319\n22.1.1 　修改SingleFragment-Activity　　320\n22.1.2 　创建包含两个fragment容器的布局　　320\n22.1.3 　使用别名资源　　322\n22.2 　Activity：fragment的托管者　　323\n22.3 　深入学习：设备屏幕尺寸的确定　　331\n第23章　深入学习intent和任务　　333\n23.1 　创建NerdLauncher项目　　333\n23.2 　解析隐式intent　　334\n23.3 　在运行时创建显式intent　　337\n23.4 　任务与后退栈　　338\n23.5 　使用NerdLauncher应用作为设备主屏幕　　341\n23.6 　挑战练习：应用图标与任务重排　　341\n23.7 　进程与任务　　341\n第24章　样式与include标签的使用　　343\n24.1 　创建RemoteControl项目　　344\n24.1.1 　编码实现RemoteControl-Activity　　344\n24.1.2 　创建RemoteControl-Fragment　　345\n24.2 　使用样式消除重复代码　　348\n24.3 　完善布局定义　　350\n24.4 　深入学习：使用include与merge标签　　353\n24.5 　挑战练习：样式的继承　　354\n第25章　XML Drawable与9-Patches　　355\n25.1 　XML drawable　　356\n25.2 　state list drawable　　358\n25.3 　layer list与inset drawable　　360\n25.4 　使用9-patch图像　　362\n第26章　HTTP与后台任务　　368\n26.1 　创建PhotoGallery应用　　369\n26.2 　网络连接基本　　372\n26.3 　使用AsyncTask在后台线程上运行代码　　373\n26.4 　线程与主线程　　375\n26.5 　获取Flickr XML数据　　377\n26.6 　从AsyncTask回到主线程　　382\n26.7 　深入学习：再探AsyncTask　　385\n26.8 　挑战练习：分页　　386\n第27章　Looper、Handler与HandlerThread　　387\n27.1 　设置GridView以显示图片　　387\n27.2 　批量下载缩略图　　390\n27.3 　与主线程通信　　390\n27.4 　创建并启动后台线程　　391\n27.5 　Message与message Handler　　393\n27.5.1 　消息的剖析　　393\n27.5.2 　Handler的剖析　　393\n27.5.3 　使用handler　　395\n27.5.4 　传递handler　　397\n27.6 　深入学习：AsyncTask与Thread　　401\n27.7 　挑战练习：预加载以及缓存　　401\n第28章　搜索　　402\n28.1 　搜索Flickr网站　　402\n28.2 　搜索对话框　　404\n28.2.1 　创建搜索界面　　404\n28.2.2 　可搜索的activity　　406\n28.2.3 　物理搜索键　　408\n28.2.4 　搜索的工作原理　　409\n28.2.5 　启动模式与新的intent　　410\n28.2.6 　使用shared preferences实现轻量级数据存储　　412\n28.3 　在Android 3.0以后版本的设备上使用SearchView　　414\n28.4 　挑战练习　　416\n第29章　后台服务　　417\n29.1 　创建IntentService　　417\n29.2 　服务的作用　　419\n29.3 　查找最新返回结果　　421\n29.4 　使用AlarmManager延迟运行服务　　422\n29.4.1 　PendingIntent　　424\n29.4.2 　使用PendingIntent管理定时器　　424\n29.5 　控制定时器　　425\n29.6 　通知信息　　428\n29.7 　深入学习：服务细节内容　　429\n29.7.1 　服务的能与不能　　430\n29.7.2 　服务的生命周期　　430\n29.7.3 　non-sticky服务　　430\n29.7.4 　sticky服务　　431\n29.7.5 　绑定服务　　431\n第30章　broadcast Intent　　433\n30.1 　随设备重启而重启的定时器　　433\n30.1.1 　配置文件中的broadcast receiver　　434\n30.1.2 　如何使用receiver　　435\n30.2 　过滤前台通知消息　　436\n30.2.1 　发送broadcast intent　　437\n30.2.2 　动态broadcast receiver　　437\n30.2.3 　使用私有权限　　440\n30.2.4 　使用ordered broadcast接收结果　　442\n30.3 　receiver与长时运行任务　　446\n第31章　网页浏览　　447\n31.1 　最后一段Flickr数据　　447\n31.2 　简单方式：使用隐式intent　　448\n31.3 　较难方式：使用WebView　　449\n31.3.1 　使用WebChromeClient优化WebView的显示　　453\n31.3.2 　处理WebView的设备旋转问题　　455\n31.4 　深入学习：注入JavaScript对象　　456\n第32章　定制视图与触摸事件　　457\n32.1 　创建DragAndDraw项目　　457\n32.1.1 　创建DragAndDraw-Activity　　458\n32.1.2 　创建DragAndDraw-Fragment　　459\n32.2 　创建定制视图　　460\n32.3 　处理触摸事件　　462\n32.4 　onDraw(...)方法内的图形绘制　　465\n32.5 　挑战练习：设备旋转问题　　467\n第33章　跟踪设备的地理位置　　468\n33.1 　启动RunTracker项目　　468\n33.1.1 　创建RunActivity　　469\n33.1.2 　创建RunFragment　　470\n33.2 　地理位置与LocationManager　　472\n33.3 　接收定位数据更新broadcast　　474\n33.4 　使用定位数据刷新UI显示　　475\n33.5 　快速定位：最近一次地理位置　　479\n33.6 　在物理和虚拟设备上测试地理位置定位　　480\n第34章　使用SQLite本地数据库　　482\n34.1 　在数据库中存储旅程和地理位置信息　　482\n34.2 　查询数据库中的旅程列表　　488\n34.3 　使用CursorAdapter显示旅程列表　　490\n34.4 　创建新旅程　　493\n34.5 　管理现有旅程　　494\n34.6 　挑战练习：识别当前跟踪的旅程　　500\n第35章　使用Loader加载异步数据　　501\n35.1 　Loader与LoaderManager　　501\n35.2 　在RunTracker应用中使用Loader　　502\n35.3 　加载旅程列表　　503\n35.4 　加载单个旅程　　506\n35.5 　加载旅程的最近一次地理位置　　509\n第36章　使用地图　　511\n36.1 　添加Maps API给RunTracker应用　　511\n36.1.1 　使用物理设备测试地图　　511\n36.1.2 　安装使用Google Play services SDK　　511\n36.1.3 　获取Google Maps API key　　512\n36.1.4 　更新RunTracker应用的manifest配置文件　　512\n36.2 　在地图上显示用户的地理位置　　513\n36.3 　显示旅程路线　　516\n36.4 　为旅程添加开始和结束地图标注　　520\n36.5 　挑战练习：实时数据更新　　521\n第37章　编后语　　522\n37.1 　终极挑战　　522\n37.2 　关于我们　　523\n37.3 　致谢　　523","pages":"523","images":{"small":"https://img3.doubanio.com/spic/s28342615.jpg","large":"https://img3.doubanio.com/lpic/s28342615.jpg","medium":"https://img3.doubanio.com/mpic/s28342615.jpg"},"alt":"https://book.douban.com/subject/25848404/","id":"25848404","publisher":"人民邮电出版社","isbn10":"7115346437","isbn13":"9787115346438","title":"Android编程权威指南","url":"https://api.douban.com/v2/book/25848404","alt_title":"Android programming: the big nerd ranch guide","author_intro":"作者简介：\nBill Phillips\nBig Nerd Ranch资深Android讲师、高级软件工程师。他与Brian Hardy合作，为Big Nerd Ranch开发了广受好评的5天Android训练营培训课程。Bill擅长透彻地理解事物的本质，并帮助其他人做到这一点。闲暇时间，Bill喜欢阅读和弹钢琴。\nBrian Hardy\nBig Nerd Ranch首席软件工程师、资深讲师。Big Nerd Ranch的Android、iOS和Ruby培训课程均由Brian设计开发。闲暇时间，Brian喜欢骑自行车和听音乐。","summary":"权威、全面、实用、易懂，是本书最大的特色。本书根据美国大名鼎鼎的Big Nerd Ranch训练营的Android培训讲义编写而成，已经为微软、谷歌、Facebook等行业巨头培养了众多专业人才。作者巧妙地把Android开发所需的庞杂知识、行业实践、编程规范等融入一本书中，通过精心编排的应用示例、循序渐进的内容组织，以及循循善诱的语言，深入地讲解了Android开发的方方面面。如果学完一章之后仍然意犹未尽，那\u201c挑战练习\u201d一定会让你大呼过瘾。本书之所以能在移动应用开发类图书中脱颖而出，还在于它真的是在与读者\u201c对话\u201d。阅读本书就好像有一位私人导师在你身边随时为你答疑解惑。\n本书适合所有对Android及移动开发感兴趣的读者，需要一定的Java编程基础。","series":{"id":"13846","title":"The Big Nerd Ranch Guide"},"price":"CNY 99.00元"},{"rating":{"max":10,"numRaters":7,"average":"0.0","min":0},"subtitle":"Automate with Arduino, Android, and Your Computer","author":["Mike Riley"],"pubdate":"2012-3-9","tags":[{"count":36,"name":"智能家居","title":"智能家居"},{"count":21,"name":"arduino","title":"arduino"},{"count":13,"name":"android","title":"android"},{"count":9,"name":"计算机","title":"计算机"},{"count":9,"name":"编程","title":"编程"},{"count":7,"name":"电子","title":"电子"},{"count":6,"name":"pragmatic","title":"pragmatic"},{"count":5,"name":"Programming","title":"Programming"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s6999202.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"200","images":{"small":"https://img3.doubanio.com/spic/s6999202.jpg","large":"https://img3.doubanio.com/lpic/s6999202.jpg","medium":"https://img3.doubanio.com/mpic/s6999202.jpg"},"alt":"https://book.douban.com/subject/6893670/","id":"6893670","publisher":"Pragmatic Bookshelf","isbn10":"1934356905","isbn13":"9781934356906","title":"Programming Your Home","url":"https://api.douban.com/v2/book/6893670","alt_title":"","author_intro":"","summary":"In Programming Your Home, technology enthusiast Mike Riley walks you through a variety of custom home automation projects, ranging from a phone application that alerts you to package deliveries at your front door to an electronic guard dog that will prevent unwanted visitors. Open locked doors using your smartphone. Assemble a bird feeder that posts Twitter tweets to tell you when the birds are feeding or when bird seed runs low. Have your home speak to you when you receive email or tell you about important events such as the arrival of visitors, and much more! Using Android smartphones, Arduinos, X10 controllers and a wide array of sensors, servos, programming languages, web frameworks and mobile SDK's, Programming Your Home is written for smartphone programmers, web developers, technology tinkerers and anyone who enjoys building cutting-edge Do It Yourself electronic projects. This book will give you the inspiration and understanding to construct amazing automation capabilities that will transform your residence into the smartest home in your neighborhood! *What You Need:* To get the most out of Programming Your Home, readers should have some familiarity with the Arduino hardware platform along with a passion for tinkering. They should enjoy innovative thinking and learning exercises as well as have some practical application development experience. The projects use a variety of hardware components including sensors and actuators, mobile devices, and wireless radios, and we'll even tell you where you can get them.","price":"GBP 23.50"},{"rating":{"max":10,"numRaters":65,"average":"3.9","min":0},"subtitle":"跨iOS、Android和沃Phone平台","author":["徐松林","黄　猛"],"pubdate":"2012-1","tags":[{"count":38,"name":"游戏引擎","title":"游戏引擎"},{"count":29,"name":"游戏编程","title":"游戏编程"},{"count":23,"name":"游戏","title":"游戏"},{"count":16,"name":"Android","title":"Android"},{"count":15,"name":"C++","title":"C++"},{"count":14,"name":"跨平台开发","title":"跨平台开发"},{"count":13,"name":"iphone","title":"iphone"},{"count":11,"name":"iOS","title":"iOS"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s8859446.jpg","binding":"平装","translator":[],"catalog":"第1 章  智能手机操作系统介绍　　 1\n1.1  iOS　　 2\n1.1.1  iOS 常见特性　　 2\n1.1.2  App Store 　　 3\n1.2  Android　　　 3\n1.2.1  Android 常见特性　　 3\n1.2.2  Android 应用商城　　 4\n1.3  其他手机操作系统　　 4\n1.3.1  OPhone 　　 4\n1.3.2  沃Phone 　　 4\n1.3.3  LEOS 　　 5\n1.4  总结　　 5\n第2 章  游戏及游戏引擎介绍　　 6\n2.1  游戏介绍　　 6\n2.2  游戏引擎介绍　　 7\n2.2.1  渲染引擎　　 8\n2.2.2  物理引擎　　 8\n2.2.3  周边工具　　10\n2.3  总结　　 10\n第3 章  进入cocos2d 的世界　　 11\n3.1  cocos2d 介绍　　 11\n3.2  cocos2d-iphone 介绍　　 12\n3.3  cocos2d-x 介绍　　13\n3.4  cocos2d-x 游戏分享　　 13\n3.5  其他cocos2d 版本介绍　　 14\n3.6  总结　　 15\n第4 章  搭建跨平台的开发环境　　 16\n4.1  环境说明　　 16\n4.2  环境搭建　　 16\n4.2.1  安装Visual Studio　　 17\n4.2.2  安装Cygwin　　 19\n4.2.3  安装iOS 环境　　 23\n4.2.4  安装Android 环境　　 26\n4.2.5  安装沃Phone 环境　　 28\n4.2.6  安装cocos2d-x 引擎　　 35\n4.3  环境测试之Hello World 案例　　 35\n4.3.1  Windows 运行　　 36\n4.3.2  iOS 运行　　 37\n4.3.3  Andriod 运行　　 38\n4.3.4  沃Phone 运行　　 38\n4.4  总结　　 40\n第5 章  cocos2d-x 引擎基础使用　　 41\n5.1  整体架构　　 41\n5.1.1  导演　　 44\n5.1.2  摄像机　　 46\n5.1.3  场景　　 47\n5.1.4  布景　　 48\n5.1.5  人物角色　　 49\n5.1.6  动作　　51\n5.2  目录结构　　 51\n5.3  坐标体系　　 53\n5.4  跨平台常量　　54\n5.5  图形　　 55\n5.6  动作　　 56\n5.7  菜单　　 59\n5.8  事件　　 60\n5.9  变量自动释放　　 61\n5.10  总结　　 62\n第6 章  cocos2d-x 之高级特性　　 63\n6.1  物理引擎　　63\n6.1.1  世界　　 63\n6.1.2  刚体及刚体定义　　 65\n6.1.3  形状　　 65\n6.1.4  关联及关联定义　　 66\n6.1.5  链接及链接定义　　 66\n6.1.6  使用案例　　 66\n6.2  粒子系统　　 67\n6.2.1  重力式粒子系统　　 71\n6.2.2  放射式粒子系统　　 72\n6.3  声音模块　　 74\n6.4  总结　　 76\n第7 章  cocos2d-x 之周边工具　　 77\n7.1  沃Phone 应用程序打包工具　　 77\n7.1.1  软件包设置　　 78\n7.1.2  应用配置　　 80\n7.1.3  添加支持文件　　 83\n7.1.4  保存编译　　 83\n7.2  图片编辑器　　 84\n7.3  地图编辑工具　　 85\n7.4  粒子系统设计工具　　 88\n7.5  总结　　 90\n第8 章  cocos2d-x 之交叉编译　　 91\n8.1  交叉编译到iOS 平台　　 91\n8.1.1  新建iOS 项目　　 91\n8.1.2  交叉编译　　 93\n8.1.3  打包运行　　 93\n8.2  交叉编译到Android 平台　　 93\n8.2.1  新建Android 项目　　 94\n8.2.2  生成编译脚本　　 94\n8.2.3  交叉编译　　96\n8.2.4  打包运行　　96\n8.3  交叉编译到沃Phone 平台　　97\n8.3.1  新建沃Phone 项目　　 97\n8.3.2  生成编译脚本　　 99\n8.3.3  交叉编译　　101\n8.3.4  打包运行　　102\n8.4  总结　　102\n第9 章  cocos2d-x 之实用篇　　 103\n9.1  游戏社交平台　　103\n9.2  手机广告平台　　104\n9.3  推广墙平台　　105\n9.4  技术准备　　105\n9.4.1 cocos2d-x 调用Objective-C　　 106\n9.4.2  cocos2d-x 调用Java 　　 107\n9.5  案例实现　　111\n9.5.1  场景分析　　111\n9.5.2  环境准备　　111\n9.5.3  游戏设计　　111\n9.5.4  游戏实现　　112\n9.5.5  场景总结　　125\n9.6  总结　　125\n第10 章  \u201c魔塔\u201d案例之基础篇　　 126\n10.1  先熟悉一下游戏　　126\n10.2  准备工作　　 126\n10.3  绘制最简单的游戏地图　　127\n10.4  人物行走　　130\n10.5  碰撞检测　　144\n10.6  总结　　146\n第11 章  \u201c魔塔\u201d案例之高级篇　　147\n11.1  重构代码　　147\n11.1.1  分离场景和图层　　 147\n11.1.2  分离游戏对象　　 149\n11.1.3  小结　　 163\n11.2  添加更多游戏元素　　 165\n11.2.1  添加怪物　　 166\n11.2.2  添加物品和门　　 175\n11.2.3  添加对象层　　 179\n11.2.4  小结　　188\n11.3  总结　　189\n第12 章  未来展望　　190\n12.1  智能手机系统的发展趋势　　 190\n12.1.1  iOS 的发展趋势　　 190\n12.1.2  Android 的发展趋势　　191\n12.1.3  沃Phone 的发展趋势　　191\n12.2  手机游戏的发展趋势　　 192\n12.2.1  手机单机游戏　　192\n12.2.2  手机网络游戏　　 193\n12.3  cocos2d-x 引擎的发展趋势　　 194","ebook_url":"https://read.douban.com/ebook/1192194/","pages":"195","images":{"small":"https://img3.doubanio.com/spic/s8859446.jpg","large":"https://img3.doubanio.com/lpic/s8859446.jpg","medium":"https://img3.doubanio.com/mpic/s8859446.jpg"},"alt":"https://book.douban.com/subject/7046664/","id":"7046664","publisher":"人民邮电","isbn10":"7115267669","isbn13":"9787115267665","title":"cocos2d-x手机游戏开发","url":"https://api.douban.com/v2/book/7046664","alt_title":"","author_intro":"徐松林  智能手机平台的先驱者，曾就职于国内知名的企业级平台软件公司，主攻复杂系统的架构设计，在此期间积累了有关大型软件架构设计的丰富经验。2010年5月 成立MT工作室，设计并开发用于Android平台的游戏引擎（MT引擎），并基于此引擎开发出多款市场反馈较好的游戏。一直专注于研究跨平台的游戏引 擎，尤其是跨平台引擎的架构及设计原理。\n    专注于移动平台游戏开发，对Android以及iOS系统的编程有深入研究。","summary":"《cocos2d-x手机游戏开发:跨iOS、Android和沃Phone平台》共有12章，以跨平台的手机游戏开发为主线，围绕着cocos2d-x引擎，由浅入深地讲解了智能手机的游戏开发过程、跨平台游戏引擎的原理、跨平台游戏引擎周边工具以及跨平台的游戏开发，还给出了完整的实战案例，语言简洁，结构清晰。《cocos2d-x手机游戏开发:跨iOS、Android和沃Phone平台》适合所有想进入智能手机平台游戏领域的人士，包括在校大学生、游戏开发者和网络游戏公司的CTO等。","ebook_price":"18.00","price":"39.00元"},{"rating":{"max":10,"numRaters":165,"average":"8.1","min":0},"subtitle":"","author":["范怀宇"],"pubdate":"2012-8","tags":[{"count":369,"name":"Android","title":"Android"},{"count":115,"name":"编程","title":"编程"},{"count":70,"name":"计算机","title":"计算机"},{"count":52,"name":"android","title":"android"},{"count":37,"name":"互联网","title":"互联网"},{"count":28,"name":"范老师","title":"范老师"},{"count":26,"name":"计算机技术","title":"计算机技术"},{"count":21,"name":"大牛之作","title":"大牛之作"}],"origin_title":"","image":"https://img1.doubanio.com/mpic/s11184539.jpg","binding":"","translator":[],"catalog":"前言\n致谢\n第1章　Android的系统架构/1\n1.1　Android系统架构概况/2\n1.1.1　应用层/4\n1.1.2　框架层/5\n1.1.3　运行时/5\n1.1.4　核心类库/7\n1.1.5　硬件抽象层和Linux内核/7\n1.2　Android的核心功能模块/8\n1.2.1　界面框架/8\n1.2.2　数据存储/9\n1.2.3　网络通信/10\n1.2.4　地理信息/11\n1.2.5　图形和多媒体处理/11\n1.2.6　外部设备/12\n1.2.7　特色功能模块/13\n1.3　Android的架构特征和设计思想/13\n1.3.1　平台开放性/14\n1.3.2　基于组件的应用设计/14\n1.3.3　基于网络服务的平台/15\n1.4　小结/15\n第2章　Android源代码的下载和编译/16\n2.1　Android源代码的获取和编译/17\n2.1.1　环境搭建/18\n2.1.2　源代码获取/18\n2.1.3　源代码的编译/21\n2.2　Android源代码结构/22\n2.2.1　框架层源代码目录frameworks/22\n2.2.2　应用层源代码目录packages/24\n2.2.3　其他源代码目录/24\n2.3　Android源代码的阅读和编辑/25\n2.3.1　用Eclipse阅读源代码/25\n2.3.2　反馈Bug/26\n2.3.3　提交修改/27\n2.4　小结/27\n第3章　Android组件模型解析/28\n3.1　基于Mashup的应用设计/29\n3.1.1　Android中的Mashup/29\n3.1.2　基于Mashup的Android应用模型/30\n3.1.3　基于Mashup的应用架构特征/32\n3.2　界面组件Activity解析/34\n3.2.1　界面组件的功能和特征/34\n3.2.2　界面组件的开发/35\n3.2.3　界面组件的数据结构/39\n3.3　服务组件Service解析/40\n3.3.1　服务组件的功能和特征/41\n3.3.2　服务组件的开发和使用/43\n3.3.3　服务组件的进程间通信模型/45\n3.4　触发器组件Broadcast Receiver解析/49\n3.4.1　触发器组件的功能和特征/49\n3.4.2　触发器组件的使用/50\n3.4.3　广播事件的发送/52\n3.5　数据源组件Content Provider解析/52\n3.5.1　数据源组件的定位和操作/53\n3.5.2　数据源组件的开发/55\n3.5.3　数据源组件的实现细节/57\n3.6　应用配置文件解析/59\n3.6.1　权限配置/61\n3.6.2　环境配置/63\n3.6.3　应用和组件配置/65\n3.7　小结/66\n第4章　Android的Intent机制/67\n4.1　Intent对象的作用和构成/68\n4.1.1　Intent对象的作用/69\n4.1.2　Intent对象的构成/70\n4.1.3　Intent对象解析/75\n4.1.4　Intent Filter对象/76\n4.2　意图匹配/78\n4.2.1　意图匹配的算法流程/79\n4.2.2　匹配组件的选择/84\n4.2.3　意图匹配的优化/85\n4.3　意图机制的应用/86\n4.3.1　意图机制在界面组件中的应用/86\n4.3.2　意图机制在服务组件中的应用/88\n4.3.3　意图机制在触发器组件中的应用/89\n4.4　小结/90\n第5章　组件生命周期解析/91\n5.1　应用进程模型/92\n5.1.1　应用、组件和进程/92\n5.1.2　组件的应用进程配置/94\n5.2　应用进程托管/96\n5.2.1　为什么需要进程托管/97\n5.2.2　进程优先级/97\n5.2.3　进程回收算法/100\n5.2.4　进程的强行终止/103\n5.2.5　掌控进程的优先级/105\n5.3　组件的生命周期模型/106\n5.3.1　界面组件的生命周期/107\n5.3.2　服务组件的生命周期/115\n5.3.3　触发器组件的生命周期/119\n5.3.4　数据源组件的生命周期/120\n5.3.5　应用环境的生命周期/120\n5.4　任务和界面组件栈/120\n5.4.1　界面组件的运行模式/122\n5.4.2　组件的任务黏度/126\n5.4.3　实际应用中的任务控制/127\n5.5　小结/128\n第6章　组件间的数据传输/129\n6.1　利用Intent对象进行数据传输/130\n6.1.1　利用Intent对象回传数据/131\n6.1.2　利用Intent对象传递数据的优缺点/133\n6.2　利用文件进行数据共享/134\n6.2.1　利用文件进行数据共享的实现/134\n6.2.2　利用文件进行数据共享的优缺点/135\n6.3　利用应用环境的全局数据共享/136\n6.3.1　利用应用环境对象共享数据的实现/137\n6.3.2　利用应用环境对象共享数据的优缺点/138\n6.4　利用组件共享数据/139\n6.4.1　利用数据源组件共享数据/139\n6.4.2　利用服务组件共享数据/140\n6.5　小结/140\n第7章　Android控件解析/141\n7.1　Android的控件框架/142\n7.1.1　Android控件构成/142\n7.1.2　Android交互事件传输/143\n7.1.3　Android控件属性/145\n7.1.4　控件的丈量和绘制/150\n7.2　Android的窗口机制/150\n7.2.1　窗口机制的基本原理/151\n7.2.2　界面组件和窗口/152\n7.2.3　对话框/154\n7.2.4　弹出窗口/156\n7.3　Android的基本控件介绍/158\n7.3.1　文本控件/159\n7.3.2　图像控件/163\n7.3.3　Surface控件/164\n7.3.4　Layout控件/164\n7.3.5　适配器控件/167\n7.3.6　选项卡控件/172\n7.3.7　浏览器控件/173\n7.4　自定义控件/175\n7.4.1　控件的定制/175\n7.4.2 　复合控件/180\n7.4.3　自绘控件/183\n7.5　Android界面新发展/188\n7.5.1　动作栏/188\n7.5.2　界面片段/191\n7.5.3　重新定制选项卡/197\n7.5.4　交互界面的适配/200\n7.6　小结/204\n第8章　应用资源/205\n8.1　Android应用资源体系/206\n8.1.1　Android的应用资源构成/206\n8.1.2　应用资源的适配/208\n8.1.3　应用资源的动态匹配/209\n8.2　应用资源的调用/213\n8.2.1　应用资源的编译和R类/213\n8.2.2　应用资源的管理/215\n8.2.3　使用应用资源/216\n8.3　应用资源的类型/217\n8.3.1　界面和样式/217\n8.3.2　字符串和常量/221\n8.3.3　图像、图形和动画/223\n8.3.4　其他资源文件/225\n8.4　小结/225\n第9章　数据存储/226\n9.1　Android的文件系统/227\n9.1.1　Android的目录结构/229\n9.1.2　Android的应用数据存储/229\n9.1.3　Android的文件操作/231\n9.2　使用设置文件/233\n9.2.1　设置文件的存储和使用/234\n9.2.2　设置界面组件/235\n9.3　使用数据库/238\n9.3.1　Android数据库实现/238\n9.3.2　Android数据库的使用/240\n9.4　存储在云端/243\n9.4.1　云端存储的架构/244\n9.4.2　云端存储的使用/245\n9.5　小结/247\n第10章　网络通信/248\n10.1　Web通信/249\n10.1.1　基于HTTP的网络连接/249\n10.1.2　联网方式的选择/252\n10.1.3　WiFi的管理/254\n10.2　蓝牙/256\n10.2.1　Android的蓝牙实现/256\n10.2.2　基于蓝牙的通信/257\n10.3　近场通信/259\n10.3.1　基于NFC的识别和通信/259\n10.3.2　基于NFC的点对点通信/263\n10.4　基于WiFi连接的P2P通信/263\n10.4.1　Android 4.0的P2P连接实现/264\n10.4.2　使用Socket进行数据传输/266\n10.5　小结/268\n第11章　地理信息服务/269\n11.1　Android的定位服务/270\n11.1.1　定位服务框架/270\n11.1.2　位置信息源/272\n11.1.3　定位选择/273\n11.1.4　定位实例/274\n11.2　Android的地址服务/277\n11.2.1　地址服务的框架/277\n11.2.2　使用地址服务/278\n11.3　Android的地图服务/279\n11.3.1　使用地图/279\n11.3.2　其他使用地图服务的方式/282\n11.4　小结/283\n第12章　多媒体处理/284\n12.1　Android的图像处理/285\n12.1.1　图像的表示/285\n12.1.2　图像的读取和输出/286\n12.1.3　图像的呈现/288\n12.1.4　图像的管理/290\n12.2　Android的音视频处理/291\n12.2.1　Android音视频的支持框架/291\n12.2.2　Android音视频的播放/292\n12.2.3　Android音视频的录制/294\n12.3　Android中相机的使用/296\n12.4　小结/300\n第13章　其他重要模块/301\n13.1　通话和短信/302\n13.1.1　Android的通话和短信框架/302\n13.1.2　通话的处理/303\n13.1.3　短信的发送和接收/305\n13.2　App Widget的使用和实现/308\n13.2.1　Android的App Widget框架/309\n13.2.2　App Widget的界面构造和Remote Views /311\n13.2.3　App Widget的事件处理和Pending Intent /313\n13.3　Android的应用内搜索/317\n13.3.1　Android应用内搜索实现框架/317\n13.3.2　为应用定制搜索功能/318\n13.3.3　全局搜索功能/322\n13.4　Android的全局通知机制/323\n13.4.1　全局通知的类型和实现/324\n13.4.2　Toast的使用/325\n13.4.3　状态栏通知/327\n13.5　Android联系人处理/331\n13.5.1　Android联系人数据存储框架/331\n13.5.2　Android联系人操作/332\n13.6　小结/334","ebook_url":"https://read.douban.com/ebook/15171473/","pages":"356","images":{"small":"https://img1.doubanio.com/spic/s11184539.jpg","large":"https://img1.doubanio.com/lpic/s11184539.jpg","medium":"https://img1.doubanio.com/mpic/s11184539.jpg"},"alt":"https://book.douban.com/subject/11530748/","id":"11530748","publisher":"机械工业出版社","isbn10":"711139058X","isbn13":"9787111390589","title":"Android开发精要","url":"https://api.douban.com/v2/book/11530748","alt_title":"","author_intro":"范怀宇，资深Android开发工程师，毕业于清华大学，从事移动开发多年，对Android系统有颇为深入的研究，开发经验十分丰富。曾就职于网易有道，负责完成了有道词典Android版、网易掌上邮Android版、网易八方Android版等项目的开发工作，现就职于豌豆实验室 ，负责豌豆荚2.0版本的设计和开发。\n作者微博：@duguguiyu（http://weibo.com/duguguiyu）\n个人站点：http://flyvenus.net","summary":"《Android开发精要》如何才能写出贴近Android设计理念、能够更加高效和可靠运行的Android应用？通过Android的源代码去了解其底层实现细节是最重要的方法之一！然而，Android系统太过于庞大，源代码实现复杂，学习的技术门槛和时间成本都很高。有没有一种方法既能帮助开发者深入理解Android应用开发，又能不被底层大量的实现细节所羁绊，迅速掌握编写高质量Android应用所需的知识？《Android开发精要》针对这个问题给出了完美的答案！它从Android繁杂的源代码中抽取出了Android开发的\u201c精华\u201d和\u201c要点\u201d，剥离了大量琐碎的底层实现细节，进行了高度概括和总结，不仅能帮助开发者迅速从宏观上理解整个Android系统的设计理念，而且能帮助开发者迅速从微观上掌握核心知识点的原理，从而编写出高质量的Android应用。\n《Android开发精要》共13章，在逻辑上分为4个部分。第一部分（1-2章）：第1章系统介绍了Android的系统架构、核心模块和设计思想，旨在让读者真正理解它的设计理念；第2章讲解了Android源代码的获取、编译、阅读和编辑的方法。第二部分（3-6章）：第3章深入阐述了Android组件机制的设计理念和重要特征，并详细介绍了4大组件的方法和原理；第4章讲解了Intent对象和Android的意图机制，阐明了Android是如何将来自不同应用、不同进程的组件整合在一起的；第5章解析了Android中各个组件的生命周期，包括组件的进程模型和线程模型；第6章从开发的角度详细阐述了组件间数据传递的解决方案，以及它们的优缺点和适用场景。第三部分（7-8章）：第7章深入讲解了Android的控件框架，结合实际项目对重要控件的实现和使用逐一进行了分析，还包含Android 4.0界面开发的实践\u201c精华\u201d；第8章分析了Android的资源体系，剖析了Android底层对资源的处理。第4部分（9-13章）：第9章讲解了Android的数据存储结构，以及不同数据存储模式的使用要点；第10章分析了Android的各种网络连接方式，涵盖NFC和基于Wifi的P2P连接等内容；第11章讲解了Android的定位服务、地址解析服务、地图服务的框架实现；第12章仔细分析了Android各种多媒体功能的实现机制；第13章对Android中比较有特色的一些模块的实现细节进行了分析。\n海报：","ebook_price":"25.00","price":"69.00元"},{"rating":{"max":10,"numRaters":118,"average":"8.0","min":0},"subtitle":"卷I","author":["邓凡平"],"pubdate":"2011-9-5","tags":[{"count":313,"name":"Android","title":"Android"},{"count":105,"name":"Andriod源码分析","title":"Andriod源码分析"},{"count":40,"name":"编程","title":"编程"},{"count":40,"name":"android","title":"android"},{"count":39,"name":"计算机","title":"计算机"},{"count":25,"name":"计算机科学","title":"计算机科学"},{"count":25,"name":"移动互联网","title":"移动互联网"},{"count":16,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s11171603.jpg","binding":"平装","translator":[],"catalog":"第1章　阅读前的准备工作 / 1\n1.1　系统架构 / 2\n1.1.1　Android系统架构 / 2\n1.1.2　本书的架构 / 3\n1.2　搭建开发环境 / 4\n1.2.1　下载源码 / 4\n1.2.2　编译源码 / 6\n1.3　工具介绍 / 8\n1.3.1　Source Insight介绍 / 8\n1.3.3　Busybox的使用 / 11\n1.4　本章小结 / 12\n第2章　深入理解JNI / 13\n2.1　JNI概述 / 14\n2.2　学习JNI的实例：MediaScanner / 15\n2.3　Java层的MediaScanner分析 / 16\n2.3.1　加载JNI库 / 16\n2.3.2　Java的native函数和总结 / 17\n2.4　JNI层MediaScanner的分析 / 17\n2.4.1　注册JNI函数 / 18\n2.4.2　数据类型转换 / 22\n2.4.3　JNIEnv介绍 / 24\n2.4.4　通过JNIEnv操作jobject / 25\n2.4.5　jstring介绍 / 27\n2.4.6　JNI类型签名介绍 / 28\n2.4.7　垃圾回收 / 29\n2.4.8　JNI中的异常处理 / 32\n2.5　本章小结 / 32\n第3章　深入理解init / 33\n3.1　概述 / 34\n3.2　init分析 / 34\n3.2.1　解析配置文件 / 38\n3.2.2　解析service / 42\n3.2.3　init控制service / 48\n3.2.4　属性服务 / 52\n3.3　本章小结 / 60\n第4章　深入理解zygote / 61\n4.1　概述 / 62\n4.2　zygote分析 / 62\n4.2.1　AppRuntime分析 / 63\n4.2.2　Welcome to Java World / 68\n4.2.3　关于zygote的总结 / 74\n4.3　SystemServer分析 / 74\n4.3.1　SystemServer的诞生 / 74\n4.3.2　SystemServer的重要使命 / 77\n4.3.3　关于 SystemServer的总结 / 83\n4.4　zygote的分裂  / 84\n4.4.1　ActivityManagerService发送请求 / 84\n4.4.2　有求必应之响应请求 / 86\n4.4.3　 关于zygote分裂的总结 / 88\n4.5　拓展思考 / 88\n4.5.1　虚拟机heapsize的限制 / 88\n4.5.2　开机速度优化 / 89\n4.5.3　Watchdog分析 / 90\n4.6　本章小结 / 93\n第5章　深入理解常见类 / 95\n5.1　概述 / 96\n5.2　以\u201c三板斧\u201d揭秘RefBase、sp和wp / 96\n5.2.1　第一板斧\u2014\u2014初识影子对象 / 96\n5.2.2　第二板斧\u2014\u2014由弱生强 / 103\n5.2.3　第三板斧\u2014\u2014破解生死魔咒 / 106\n5.2.4　轻量级的引用计数控制类LightRefBase / 108\n5.2.5　题外话\u2014三板斧的来历 / 109\n5.3　Thread类及常用同步类分析 / 109\n5.3.1　一个变量引发的思考 / 109\n5.3.2　常用同步类 / 114\n5.4　Looper和Handler类分析 / 121\n5.4.1　Looper类分析 / 122\n5.4.2　Handler分析 / 124\n5.4.3　Looper和Handler的同步关系 / 127\n5.4.4　HandlerThread介绍 / 129\n5.5　本章小结 / 129\n第6章　深入理解Binder / 130\n6.1　概述 / 131\n6.2　庖丁解MediaServer / 132\n6.2.1　MediaServer的入口函数 / 132\n6.2.2　独一无二的ProcessState / 133\n6.2.3　时空穿越魔术\u2014defaultServiceManager / 134\n6.2.4　注册MediaPlayerService / 142\n6.2.5　秋风扫落叶\u2014StartThread Pool和join Thread Pool分析 / 149\n6.2.6　你彻底明白了吗 / 152\n6.3　服务总管ServiceManager / 152\n6.3.1　ServiceManager的原理 / 152\n6.3.2　服务的注册 / 155\n6.3.3　ServiceManager存在的意义 / 158\n6.4　MediaPlayerService和它的Client / 158\n6.4.1　查询ServiceManager / 158\n6.4.2　子承父业 / 159\n6.5　拓展思考 / 162\n6.5.1　Binder和线程的关系 / 162\n6.5.2　有人情味的讣告 / 163\n6.5.3　匿名Service / 165\n6.6　学以致用 / 166\n6.6.1　纯Native的Service / 166\n6.6.2　扶得起的\u201c阿斗\u201d（aidl） / 169\n6.7　本章小结 / 172\n第7章　深入理解Audio系统 / 173\n7.1　概述 / 174\n7.2　AudioTrack的破解 / 174\n7.2.1　用例介绍 / 174\n7.2.2　AudioTrack（Java空间）分析 / 179\n7.2.3　AudioTrack（Native空间）分析 / 188\n7.2.4　关于AudioTrack的总结 / 200\n7.3　AudioFlinger的破解 / 200\n7.3.1　AudioFlinger的诞生 / 200\n7.3.2　通过流程分析AudioFlinger / 204\n7.3.3　audio_track_cblk_t分析 / 230\n7.3.4　关于AudioFlinger的总结 / 234\n7.4　AudioPolicyService的破解 / 234\n7.4.1　AudioPolicyService的创建 / 235\n7.4.2　重回AudioTrack / 245\n7.4.3　声音路由切换实例分析 / 251\n7.4.4　关于AudioPolicy的总结 / 262\n7.5　拓展思考 / 262\n7.5.1　DuplicatingThread破解 / 262\n7.5.2　题外话 / 270\n7.6　本章小结 / 272\n第8章　深入理解Surface系统 / 273\n8.1　概述 / 275\n8.2　一个Activity的显示 / 275\n8.2.1　Activity的创建 / 275\n8.2.2　Activity的UI绘制 / 294\n8.2.3　关于Activity的总结 / 296\n8.3　初识Surface / 297\n8.3.1　和Surface有关的流程总结 / 297\n8.3.2　Surface之乾坤大挪移 / 298\n8.3.3　乾坤大挪移的JNI层分析 / 303\n8.3.4　Surface和画图 / 307\n8.3.5　初识Surface小结 / 309\n8.4　深入分析Surface / 310\n8.4.1　与Surface相关的基础知识介绍 / 310\n8.4.2　SurfaceComposerClient分析 / 315\n8.4.3　SurfaceControl分析 / 320\n8.4.4　writeToParcel和Surface对象的创建 / 331\n8.4.5　lockCanvas和unlockCanvasAndPost分析 / 335\n8.4.6　GraphicBuffer介绍 / 344\n8.4.7　深入分析Surface的总结 / 353\n8.5　SurfaceFlinger分析 / 353\n8.5.1　SurfaceFlinger的诞生 / 354\n8.5.2　SF工作线程分析 / 359\n8.5.3　Transaction分析 / 368\n8.5.4　关于SurfaceFlinger的总结 / 376\n8.6　拓展思考 / 377\n8.6.1　Surface系统的CB对象分析 / 377\n8.6.2　ViewRoot的你问我答 / 384\n8.6.3　LayerBuffer分析 / 385\n8.7　本章小结 / 394\n第9章　深入理解Vold和Rild / 395\n9.1　概述 / 396\n9.2　Vold的原理与机制分析 / 396\n9.2.1　Netlink和Uevent介绍 / 397\n9.2.2　初识Vold / 399\n9.2.3　NetlinkManager模块分析 / 400\n9.2.4　VolumeManager模块分析 / 408\n9.2.5　CommandListener模块分析 / 414\n9.2.6　Vold实例分析 / 417\n9.2.7　关于Vold的总结 / 428\n9.3　Rild的原理与机制分析 / 428\n9.3.1　初识Rild / 430\n9.3.2　RIL_startEventLoop分析 / 432\n9.3.3　RIL_Init分析 / 437\n9.3.4　RIL_register分析 / 444\n9.3.5　关于Rild main函数的总结 / 447\n9.3.6　Rild实例分析 / 447\n9.3.7　关于Rild的总结 / 459\n9.4　拓展思考 / 459\n9.4.1　嵌入式系统的存储知识介绍 / 459\n9.4.2　Rild和Phone的改进探讨 / 462\n9.5　本章小结 / 463\n第10章　深入理解MediaScanner / 464\n10.1　概述 / 465\n10.2　android.process.media分析 / 465\n10.2.1　MSR模块分析 / 466\n10.2.2　MSS模块分析 / 467\n10.2.3　android.process.media媒体扫描工作的流程总结 / 471\n10.3　MediaScanner分析 / 472\n10.3.1　Java层分析 / 472\n10.3.2　JNI层分析 / 476\n10.3.3　PVMediaScanner分析 / 479\n10.3.4　关于MediaScanner的总结 / 485\n10.4　拓展思考 / 486\n10.4.1　MediaScannerConnection介绍 / 486\n10.4.2　我问你答 / 487\n10.5　本章小结 / 488","pages":"488","images":{"small":"https://img3.doubanio.com/spic/s11171603.jpg","large":"https://img3.doubanio.com/lpic/s11171603.jpg","medium":"https://img3.doubanio.com/mpic/s11171603.jpg"},"alt":"https://book.douban.com/subject/6802440/","id":"6802440","publisher":"机械工业出版社","isbn10":"7111357620","isbn13":"9787111357629","title":"深入理解Android","url":"https://api.douban.com/v2/book/6802440","alt_title":"","author_intro":"邓凡平，资深Android开发工程师，热衷于Android源代码的研究，对Android的架构设计和实现原理有非常深刻的认识和理解，应用开发经验也十分丰富。目前就职于国内一家领先的Android企业，负责Framework的开发和维护。乐于分享，活跃于CSDN等专业社区，撰写的Android Framework源码的系列文章深受读者欢迎。此外，他对Linux内核、C/C++/Python相关的技术，以及高性能网络服务器和多核并行开发等也有一定的研究。","summary":"《深入理解Android：卷I》是一本以情景方式对Android的源代码进行深入分析的书。内容广泛，以对Framework层的分析为主，兼顾Native层和Application层；分析深入，每一部分源代码的分析都力求透彻；针对性强，注重实际应用开发需求，书中所涵盖的知识点都是Android应用开发者和系统开发者需要重点掌握的。\n全书共10章，第1章介绍了阅读本书所需要做的准备工作，主要包括对Android系统架构和源码阅读方法的介绍；第2章通过对Android系统中的MediaScanner进行分析，详细讲解了Android中十分重要的JNI技术；第3章分析了init进程，揭示了通过解析init.rc来启动Zygote以及属性服务的工作原理；第4章分析了Zygote、SystemServer等进程的工作机制，同时还讨论了Android的启动速度、虚拟机HeapSize的大小调整、Watchdog工作原理等问题；第5章讲解了Android系统中常用的类，包括sp、wp、RefBase、Thread等类，同步类，以及Java中的Handler类和Looper类，掌握这些类的知识后方能在后续的代码分析中做到游刃有余；第6章以MediaServer为切入点，对Android中极为重要的Binder进行了较为全面的分析，深刻揭示了其本质。第7章对Audio系统进行了深入的分析，尤其是AudioTrack、AudioFlinger和AudioPolicyService等的工作原理。第8章深入讲解了Surface系统的实现原理，分析了Surface与Activity之间以及Surface与SurfaceFlinger之间的关系、SurfaceFlinger的工作原理、Surface系统中的帧数据传输以及LayerBuffer的工作流程。第9章对Vold和Rild的原理和机制进行了深入的分析，同时还探讨了Phone设计优化的问题；第10章分析了多媒体系统中MediaScanner的工作原理。\n本书适合有一定基础的Android应用开发工程师和系统工程师阅读。通过对本书的学习，大家将能更深刻地理解Android系统，从而自如应对实际开发中遇到的难题。","series":{"id":"28292","title":"深入理解Android"},"price":"69.00元"},{"rating":{"max":10,"numRaters":16,"average":"7.3","min":0},"subtitle":"Android开发必知的50个诀窍(china-pub首发)","author":["Carlos Sessa"],"pubdate":"2014-4","tags":[{"count":27,"name":"android","title":"android"},{"count":22,"name":"Android","title":"Android"},{"count":14,"name":"android开发","title":"android开发"},{"count":6,"name":"高质量","title":"高质量"},{"count":4,"name":"编程","title":"编程"},{"count":3,"name":"进阶开发","title":"进阶开发"},{"count":3,"name":"技术","title":"技术"},{"count":2,"name":"已经有了","title":"已经有了"}],"origin_title":"50 Android Hacks","image":"https://img1.doubanio.com/mpic/s27259607.jpg","binding":"平装","translator":["杨云君"],"catalog":"《打造高质量android应用：android开发必知的50个诀窍》\n推荐序\n序\n致谢\n关于本书\n关于原书封面插图\n第1章　活用布局\t1\nhack 1　使用weight属性实现视图的居中显示\t1\n1.1　合用weightsum属性和layout_weight属性\t2\n1.2　概要\t4\n1.3　外部链接\t4\nhack 2　使用延迟加载以及避免代码重复\t4\n2.1　使用[include /]标签避免代码重复\t5\n2.2　通过viewstub实现view的延迟加载\t7\n2.3　概要\t9\n2.4　外部链接\t9\nhack 3　创建定制的viewgroup\t10\n3.1　理解android绘制视图的方式\t11\n3.2　创建cascadelayout\t12\n3.3　为子视图添加自定义属性\t15\n.3.4　概要\t17\n3.5　外部链接\t17\nhack 4　偏好设置使用技巧\t17\n4.1　概要\t20\n4.2　外部链接\t20\n第2章　添加悦目的动画效果\t21\nhack 5　使用textswitcher和imageswitcher实现平滑过渡\t21\n5.1　概要\t23\n5.2　外部链接\t23\nhack 6　为viewgroup的子视图添加悦目的动画效果\t24\n6.1　概要\t26\n6.2　外部链接\t26\nhack 7　在canvas上显示动画\t26\n7.1　概要\t28\n7.2　外部链接\t28\nhack 8　附加ken burns特效的幻灯片\t29\n8.1　概要\t31\n8.2　外部链接\t31\n第3章　使用视图的技巧和窍门\t33\nhack 9　避免在edittext中验证日期\t33\n9.1　概要\t34\n9.2　外部链接\t35\nhack 10　格式化textview的文本\t35\n10.1　概要\t36\n10.2　外部链接\t37\nhack 11　为文本添加发亮的效果\t37\n11.1　概要\t39\n11.2　外部链接\t39\nhack 12　为背景添加圆角边框\t39\n12.1　概要\t40\n12.2　外部链接\t40\nhack 13　在oncreate()方法中获取view的宽度和高度\t40\n13.1　概要\t42\n13.2　外部链接\t42\nhack 14　videoview的转屏处理技巧\t42\n14.1　概要\t46\n14.2　外部链接\t46\nhack 15　移除背景以提升activity启动速度\t46\n15.1　概要\t48\n15.2　外部链接\t48\nhack 16　更改toast显示位置的技巧\t48\n16.1　概要\t50\n16.2　外部链接\t50\nhack 17　使用gallery创建向导表单\t50\n17.1　概要\t55\n17.2　外部链接\t55\n第4章　实用工具\t56\nhack 18　在发布正式版本前移除日志语句\t56\n18.1　概要\t57\n18.2　外部链接\t58\nhack 19　使用hierarchy viewer工具移除不必要的视图\t58\n19.1　概要\t62\n19.2　外部链接\t62\n第5章　模式\t63\nhack 20　模型\u2013视图\u2013主导器模式\t63\n20.1　概要\t66\n20.2　外部链接\t66\nhack 21　与activity生命周期绑定的broadcastreceiver\t66\n21.1　概要\t68\n21.2　外部链接\t68\nhack 22　使用android库项目时适用的架构模式\t69\n22.1　后台逻辑和模型\t69\n22.2　库项目\t70\n22.3　android应用程序\t71\n22.4　概要\t71\n22.5　外部链接\t72\nhack 23　同步适配器模式\t72\n23.1　一般方法\t72\n23.2　我的方法\t74\n23.3　概要\t89\n23.4　外部链接\t89\n第6章　活用列表和适配器\t91\nhack 24　处理空列表\t91\n24.1　概要\t92\n24.2　外部链接\t92\nhack 25　通过viewholder优化适配器\t93\n25.1　概要\t95\n25.2　外部链接\t95\nhack 26　为listview添加分段标头\t95\n26.1　创建列表布局\t97\n26.2　创建可视分段标头\t98\n26.3　最后一步\t99\n26.4　概要\t100\n26.5　外部链接\t100\nhack 27　使用activity和delegate与适配器交互\t101\n27.1　概要\t103\n27.2　外部链接\t103\nhack 28　充分利用listview的头视图\t103\n28.1　概要\t106\n28.2　外部链接\t106\nhack 29　在viewpager中处理转屏\t106\n29.1　概要\t108\n29.2　外部链接\t108\nhack 30　listview的选择模式\t108\n30.1　概要\t112\n30.2　外部链接\t113\n第7章　实用库\t114\nhack 31　android面向切面编程\t114\n31.1　概要\t118\n31.2　外部链接\t118\nhack 32　使用cocos2d-x美化应用程序\t118\n32.1　cocos2d-x是什么\t119\n32.2　使用cocos2d-x\t119\n32.3　概要\t123\n32.4　外部链接\t123\n第8章　与其他编程语言交互\t125\nhack 33　在android上运行objective-c\t125\n33.1　下载并编译itoa\t126\n33.2　划分模块\t127\n33.3　创建java层代码\t131\n33.4　概要\t132\n33.5　外部链接\t133\nhack 34　在android中使用scala\t133\n34.1　概要\t136\n34.2　外部链接\t137\n第9章　可复用的代码片段\t138\nhack 35　同时发起多个intent\t138\n35.1　拍照\t139\n35.2　从相册中选择照片\t139\n35.3　整合两种intent\t139\n35.4　概要\t140\n35.5　外部链接\t140\nhack 36　在用户反馈中收集信息\t140\n36.1　概要\t143\n36.2　外部链接\t143\nhack 37　向media contentprovider添加mp3文件\t143\n37.1　使用contentvalues添加mp3文件\t144\n37.2　使用mediascanner添加mp3文件\t144\n37.3　概要\t145\n37.4　外部链接\t145\nhack 38　为actionbar添加刷新动作\t145\n38.1　概要\t149\n38.2　外部链接\t149\nhack 39　从market中获取依赖功能\t149\n39.1　概要\t151\n39.2　外部链接\t152\nhack 40　以后进先出方式加载图片\t152\n40.1　起点：android示例程序\t152\n40.2　引入executor\t153\n40.3　ui线程\u2014离开返回的无缝衔接\t155\n40.4　注意事项\t155\n40.5　概要\t155\n40.6　外部链接\t156\n第10章　数据库进阶\t157\nhack 41　使用ormlite构建数据库\t157\n41.1　一个简单的数据模型\t158\n41.2　开始\t159\n41.3　坚如磐石的数据库schema\t160\n41.4　sqliteopenhelper\u2014\u2014数据库通道\t163\n41.5　用于数据库访问的单例模式\t165\n41.6　crud操作一点通\t166\n41.7　查询构建器\t167\n41.8　数据类型和棘手的外部类型\t169\n41.9　原生sql查询\t172\n41.10　事务\t174\n41.11　概要\t175\n41.12　外部链接\t176\nhack 42　为sqlite添加自定义功能\t176\n42.1　java代码\t177\n42.2　native代码\t178\n42.3　概要\t180\n42.4　外部链接\t180\nhack 43　数据库批处理\t181\n43.1　不使用批处理操作\t182\n43.2　使用批处理操作\t183\n43.3　使用sqlitecontentprovider执行批处理操作\t184\n43.4　概要\t186\n43.5　外部链接\t186\n第11章　避免代码碎片化\t187\nhack 44　处理熄灯模式\t187\n44.1　android 2.x\t188\n44.2　android 3.x\t189\n44.3　在一个activity中整合两种实现\t190\n44.4　概要\t190\n44.5　外部链接\t191\nhack 45　在旧版本上使用新api\t191\n45.1　使用apply()替代commit()\t191\n45.2　将应用程序安装到sd卡中\t194\n45.3　概要\t195\n45.4　外部链接\t195\nhack 46　向后兼容的通知\t196\n46.1　概要\t200\n46.2　外部链接\t200\nhack 47　使用fragment创建tab\t201\n47.1　创建自定义tab的ui界面\t201\n47.2　在activity中放置tab\t202\n47.3　概要\t203\n47.4　外部链接\t203\n第12章　构建工具\t204\nhack 48　使用apache maven处理依赖关系\t204\n48.1　概要\t208\n48.2　外部链接\t208\nhack 49　在root过的设备上安装依赖库\t209\n49.1　dex预处理\t211\n49.2　创建与权限相关的xml文件\t211\n49.3　修改androidmanifest.xml文件\t212\n49.4　概要\t212\n49.5　外部链接\t212\nhack 50　使用jenkins处理设备多样性\t213\n50.1　创建jenkins job\t215\n50.2　运行job\t217\n50.3　概要\t218\n50.4　外部链接\t219","ebook_url":"https://read.douban.com/ebook/30898123/","pages":"219","images":{"small":"https://img1.doubanio.com/spic/s27259607.jpg","large":"https://img1.doubanio.com/lpic/s27259607.jpg","medium":"https://img1.doubanio.com/mpic/s27259607.jpg"},"alt":"https://book.douban.com/subject/25866305/","id":"25866305","publisher":"机械工业出版社","isbn10":"7111461363","isbn13":"9787111461364","title":"打造高质量Android应用","url":"https://api.douban.com/v2/book/25866305","alt_title":"50 Android Hacks","author_intro":"carlos sessa，资深android开发工程师，nasa trained monkeys移动开发公司联合创始人。他活跃于stack overflow，是一位狂热的hack收集者，专注于为android和ios等移动开发平台提供解决方案。\n杨云君，资深android系统工程师，不仅在 android应用开发方面积累了丰富的经验，而且熟悉android系统级开发和性能优化，对android系统的架构没汁与实现原理有深入研究。现就职于国际领先的移动通信公司，参与过多款旗舰产品的系统级开发和升级工作，并负责odm产品的性能优化。著有《android的设计与实现：卷i》。","summary":"《打造高质量Android应用：Android开发必知的50个诀窍》是目前唯一一本从开发技巧角度讲解 Android应用开发的著作，旨在迅速提高开发者解决各种疑难问题的能力，从而打造出高质量的 Android应用。作译者都是经验丰富的Android开发工程师，作者悉心总结Android应用开发中会遇到的50个经典问题，这些问题涉及布局、动画、视图、工具、列表、适配器、实用库、与其他编程语言的交互、数据库、构建工具、代码复用、避免代码碎片化等多个方面。本书以\u201c问题解决方案\u201d的形式给出疑难问题的解决方案，同时结合示例代码，深入剖析这些实用的编程技巧和模式，旨在帮助开发人员提高编程效率，改进代码质量，打造高质量的Android应用。","ebook_price":"20.00","series":{"id":"28292","title":"深入理解Android"},"price":"49.00"},{"rating":{"max":10,"numRaters":241,"average":"6.4","min":0},"subtitle":"","author":["姚尚朗","靳岩"],"pubdate":"2009 年6月","tags":[{"count":234,"name":"Android","title":"Android"},{"count":54,"name":"Google","title":"Google"},{"count":51,"name":"编程","title":"编程"},{"count":40,"name":"应用开发","title":"应用开发"},{"count":32,"name":"程序设计","title":"程序设计"},{"count":25,"name":"计算机","title":"计算机"},{"count":21,"name":"java","title":"java"},{"count":20,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s3817805.jpg","binding":"16开","translator":[],"catalog":"第1章　掀起你的盖头来\u2014\u2014初识android　1\n1.1　认识android　1\n1.2　android的背景　2\n1.2.1　android的历史　2\n1.2.2　android的发展　2\n1.3　我的android我做主　2\n1.3.1　开发基于android平台的应用　3\n1.3.2　参加android开发者大赛　3\n1.3.3　个人英雄主义再现\u2014\u2014得到更多人的认可和尊重　3\n1.3.4　获得应有的收益\u2014\u2014android market　3\n1.4　真实体验\u2014\u2014android模拟器　4\n1.4.1　模拟器概述　4\n1.4.2　模拟器和真机的区别　4\n1.4.3　模拟器使用注意事项　4\n1.5　更上一层楼\u2014\u2014加入android开发社区　5\n1.6　本章小结　6\n第2章　工欲善其事　必先利其器\u2014\u2014搭建android开发环境　7\n2.1　开发android应用前的准备　7\n2.1.1　android开发系统要求　7\n2.1.2　android软件开发包　7\n2.1.3　其他注意事项　8\n2.2　windows开发环境搭建　8\n2.2.1　jdk、eclipse、android sdk软件安装　8\n2.2.2　sdk的家在哪里\u2014\u2014设定android sdk home　14\n2.2.3　真的准备好了吗\u2014\u2014开发环境验证　14\n2.2.4　创建android 虚拟设备(avd)　15\n2.3　linux一族\u2014\u2014ubuntu开发环境搭建　17\n2.3.1　java、eclipse和adt插件安装　17\n2.3.2　设定android sdk home　23\n2.4　mac os一族\u2014\u2014苹果开发环境搭建　24\n2.5　本章小结　24\n第3章　清点可用资本\u2014\u2014android sdk介绍　25\n3.1　android sdk 基础　25\n3.2　深入探寻android sdk的密码　25\n3.2.1　android sdk目录结构　25\n3.2.2　android.jar及内部结构　27\n3.2.3　sdk文档及阅读技巧　27\n3.2.4　先来热热身\u2014\u2014android sdk例子解析　28\n3.2.5　sdk提供的工具介绍　31\n3.3　android典型包分析　33\n3.3.1　开发的基石\u2014\u2014android api核心开发包介绍　33\n3.3.2　拓展开发外延\u2014\u2014android可选api介绍　34\n3.4　本章小结　34\n第4章　赚钱的市场\u2014\u2014android market及应用发布　35\n4.1　google market产生背景与目的　35\n4.2　体验\u201c选货\u201d的乐趣\u2014\u2014在g1上体验market的使用　35\n4.3　android开发活动及特色应用　37\n4.3.1　开发应用的领域　37\n4.3.2　android market特色应用一览　38\n4.4　你也可以做东家\u2014\u2014申请market账号　43\n4.4.1　卖东西要先入伙\u2014\u2014准备工作　43\n4.4.2　入伙过程\u2014\u2014申请　44\n4.5　开张了\u2014\u2014在market上发布应用　45\n4.5.1　发布时可能遇到的错误　45\n4.5.2　卖东西也要签名\u2014\u2014生成签名文件　46\n4.5.3　打包、签名、发布应用　48\n4.6　本章小结　51\n第5章　千里之行 始于足下\u2014\u2014第一个应用helloworld　52\n5.1　helloworld应用分析　52\n5.1.1　新建一个android工程　52\n5.1.2　填写工程的信息　52\n5.1.3　编程实现　53\n5.1.4　运行项目　54\n5.2　调试项目　54\n5.2.1　设置断点　54\n5.2.2　debug 项目　55\n5.2.3　断点调试　55\n5.3　本章小结　56\n第6章　磨刀不误砍柴工\u2014\u2014android应用程序结构介绍　57\n6.1　android体系结构介绍　57\n6.1.1　应用程序(application)　57\n6.1.2　应用程序框架(application framework)　58\n6.1.3　库(libraries)和运行环境(runtime)　58\n6.2　android 应用程序组成　59\n6.2.1　activity介绍　59\n6.2.2　broadcast intent receiver介绍　60\n6.2.3　service介绍　61\n6.2.4　content provider介绍　61\n6.3　android应用工程文件组成　61\n6.4　本章小结　62\n第7章　良好的学习开端\u2014\u2014android基本组件介绍　63\n7.1　第一印象很重要\u2014\u2014界面ui元素介绍　63\n7.1.1　视图组件(view)　63\n7.1.2　视图容器组件(viewgroup)　63\n7.1.3　布局组件(layout)　64\n7.1.4　布局参数(layoutparams)　64\n7.2　我的美丽我做主\u2014\u2014android中应用界面布局　64\n7.2.1　实例操作演示　65\n7.2.2　实例编程实现　66\n7.3　不积跬步 无以至千里\u2014\u2014常用widget组件介绍　75\n7.3.1　创建widget组件实例　75\n7.3.2　按钮(button)介绍与应用　76\n7.3.3　文本框(textview)介绍与应用　77\n7.3.4　编辑框(edittext)介绍与应用　79\n7.3.5　多项选择(checkbox)介绍与应用　81\n7.3.6　单项选择(radiogroup )介绍与应用　83\n7.3.7　下拉列表(spinner )介绍与应用　85\n7.3.8　自动完成文本(autocompletetextview )　87\n7.3.9　日期选择器(datepicker)介绍与应用　89\n7.3.10　时间选择器(timepicker)介绍与应用　90\n7.3.11　滚动视图(scrollview)介绍与应用　91\n7.3.12　进度条(progressbar)介绍与应用　92\n7.3.13　拖动条(seekbar)介绍与应用　93\n7.3.14　评分组件(ratingbar)介绍与应用　94\n7.3.15　图片视图(imageview)介绍与应用　95\n7.3.16　图片按钮(imagebutton)介绍与应用　96\n7.3.17　切换图片(imageswitcher&gallery)　96\n7.3.18　网格视图(gridview)介绍与应用　99\n7.3.19　标签(tab)介绍与应用　101\n7.4　友好的菜单\u2014\u2014menu介绍与实例　102\n7.4.1　实例操作演示..　103\n7.4.2　实例编程实现　103\n7.5　android应用的灵魂\u2014\u2014intent和activity介绍与实例　106\n7.5.1　实例操作演示　106\n7.5.2　实例编程实现　106\n7.6　用好列表，做好程序\u2014\u2014列表(listview)介绍与实例　111\n7.6.1　实例程序演示　111\n7.6.2　实例编程实现　112\n7.7　友好地互动交流\u2014\u2014对话框(dialog)介绍与实例　119\n7.8　温馨的提醒\u2014\u2014toast和notification应用　127\n7.8.1　实例操作演示　128\n7.8.2　实例编程实现　129\n7.9　本章小结　135\n第8章　移动信息仓库\u2014\u2014android的数据存储操作　136\n8.1　android数据存储概述　136\n8.2　轻轻地我保护\u2014\u2014sharedpreferences存储　136\n8.3　谁的文件，谁主宰\u2014\u2014文件存储　140\n8.4　打造自己的数据库存储\u2014\u2014sqlite存储方式　141\n8.4.1　android中对数据库操作　141\n8.4.2　完整地操作数据库\u2014\u2014日记本实例　147\n8.5　我的数据你来用\u2014\u2014contentprovider介绍　155\n8.5.1　初识contentprovider　155\n8.5.2　使用contentprovider读取系统数据　156\n8.5.3　使用contentprovider操作数据日记本实例　159\n8.6　再学一招\u2014\u2014网络存储　171\n8.7　本章小结　173\n第9章　我来\u201c广播\u201d你的\u201c意图\u201d\u2014\u2014intent和broadcast面对面　174\n9.1　android应用程序的核心\u2014\u2014intent　174\n9.1.1　intent基础　174\n9.1.2　用intent启动一个新的activity　174\n9.1.3　intent 详细讲解　177\n9.1.4　android解析intent实现　179\n9.2　用广播告诉你\u2014\u2014利用intent来广播(broadcast)事件　180\n9.2.1　实现android中的广播事件　180\n9.2.2　broadcast receiver介绍　181\n9.3　应用实例详解　181\n9.3.1　程序操作演示　182\n9.3.2　实例编程实现　182\n9.4　本章小结　186\n第10章　一切为用户服务\u2014\u2014service应用实例　187\n10.1　认识service　187\n10.2　使用service　188\n10.3　service的生命周期　194\n10.4　实例学习service　194\n10.4.1　精彩实例一\u2014\u2014定时提醒　194\n10.4.2　精彩实例二\u2014\u2014音乐播放器　198\n10.5　本章小结　201\n第11章　循序渐进\u2014\u2014开发android应用的基本步骤　202\n11.1　兵马未动 粮草先行\u2014\u2014应用规划及架构设计　202\n11.2　应用开发步骤　202\n11.2.1　界面设计始终是第一位\u2014\u2014实现ui　203\n11.2.2　必备的动力源泉\u2014\u2014数据操作和存储　203\n11.2.3　华丽转身\u2014\u2014实现多页面跳转　203\n11.2.4　始终为用户做好服务\u2014\u2014增加service　203\n11.2.5　细节决定成败\u2014\u2014完善应用细节　203\n11.3　成功就在眼前\u2014\u2014应用测试和发布　204\n11.3.1 只欠东风\u2014\u2014应用测试　204\n11.3.2　可以赚钱了\u2014\u2014发布到android market　204\n11.4　本章小结　204\n第12章　android综合案例一\u2014\u2014rss阅读器实例　205\n12.1　rss介绍　205\n12.1.1　rss基础　205\n12.1.2　rss的历史　205\n12.1.3　rss语法介绍　206\n12.2　sax介绍　207\n12.2.1　sax基础　207\n12.2.2　使用sax的作用　207\n12.2.3　怎样使用sax　207\n12.3　rss阅读器设计　209\n12.3.1　rss阅读器功能设计　209\n12.3.2　rss阅读器ui和交互流程设计　209\n12.4　rss阅读器的实现　210\n12.4.1　程序实体解析　210\n12.4.2　实现一个自己的contenthandler　214\n12.4.3　activity的实现　217\n12.5　本章小结　220\n第13章　android综合案例二\u2014\u2014基于google map开发个人移动地图　221\n13.1　项目ui规划　221\n13.2　数据存储实现　222\n13.2.1　设计数据库及表结构　222\n13.2.2　设计sharepreference 存储　223\n13.3　项目实现流程　223\n13.3.1　创建项目工程　223\n13.3.2　项目各功能及界面实现　224\n13.3.3　实现数据存取　247\n13.3.4　实现service　252\n13.3.5　应用流程整体实现　254\n13.3.6　后续开发完善　255\n13.4　项目程序演示　255\n13.5　项目程序签名、打包和发布　257\n13.6　本章小结　259\n第14章　android综合案例三\u2014\u2014基于android的豆瓣网(web 2.0)移动客户端开发　260\n14.1　关于豆瓣网和豆瓣网api　260\n14.1.1　豆瓣网介绍　260\n14.1.2　豆瓣网api介绍　261\n14.1.3　豆瓣网api认证　261\n14.1.4　豆瓣网api快速入门　264\n14.1.5　豆瓣网api java库介绍　265\n14.2　豆瓣网(web 2.0)客户端设计　268\n14.2.1　客户端功能规划设计　268\n14.2.2　ui和交互流程设计　268\n14.2.3　数据存储设计　270\n14.3　豆瓣网(web 2.0)客户端实现　270\n14.3.1　申请api key　270\n14.3.2　activity实现　271\n14.4　本章小结　282\n第15章　android综合案例四\u2014\u2014在线音乐播放器　283\n15.1　关于yobo和yobo api　283\n15.1.1　yobo简介　284\n15.1.2　yobo功能特点　284\n15.1.3　yobo api介绍　284\n15.2　在线播放器架构设计　285\n15.2.1　在线播放器功能规划设计　285\n15.2.2　在线播放器ui设计　285\n15.2.3　在线播放器数据存储设计　286\n15.3　在线播放器的编程实现　286\n15.3.1　申请api key　286\n15.3.2　基础功能实现　287\n15.3.3　实现activity　290\n15.3.4　实现service　306\n15.3.5　后续开发展望　310\n15.4　在线音乐播放器应用演示　310\n15.5　在线音乐播放器应用打包、签名和发布　311\n15.6　本章小结　311\n第16章　android综合案例五\u2014\u2014手机信息查看助手　312\n16.1　手机信息查看助手功能规划和可行性分析　312\n16.1.1　手机信息查看助手功能规划　312\n16.1.2　手机信息查看助手可行性分析　312\n16.2　手机信息查看助手功能实现　313\n16.2.1　手机信息查看助手主界面　313\n16.2.2　查看系统信息实现　316\n16.2.3　查看硬件信息　320\n16.2.4　查看软件信息　324\n16.2.5　获取运行时信息　326\n16.2.6　文件浏览器　328\n16.2.7　项目的细节完善　331\n16.3　手机信息查看助手功能展望　332\n16.4　项目的打包、签名和发布　332\n16.5　本章小结　333\n第17章　芝麻开门\u2014\u2014android底层开发和移植概述　334\n17.1　android原始码下载　334\n17.2　实机测试　335\n17.2.1　neo freerunner 介绍　335\n17.2.2　烧录androidfs.jffs2　336\n17.3　android移植技术概论　337\n17.3.1　android底层技术的重要性　337\n17.3.2　android移植项目介绍　338\n17.3.3　android的技术优点　340","pages":"400","images":{"small":"https://img3.doubanio.com/spic/s3817805.jpg","large":"https://img3.doubanio.com/lpic/s3817805.jpg","medium":"https://img3.doubanio.com/mpic/s3817805.jpg"},"alt":"https://book.douban.com/subject/3770255/","id":"3770255","publisher":"人民邮电出版社","isbn10":"7115209308","isbn13":"9787115209306","title":"Google Android开发入门与实战","url":"https://api.douban.com/v2/book/3770255","alt_title":"","author_intro":"本书由国内Android知名专业开发团队eoeMobile团队倾心撰写。eoeMoblie团队国内最早一批专注于Android开发的专业团队，目前团队已经在Google Market上有超过5款的作品，而且取得了可喜的下载量。国内著名网站豆瓣网的Android客户端(eoeDouban)也是由此团队制作。关于此团队的更多信息请访问:http://www.eoemobile.com.关于图书的进展，可以访问http://www.eoeandroid.com 社区\n作者简介：\n靳岩:\n网名：海阳|haiyangjy\nblog: http://www.haiyangjy.com\n姚尚朗:\n网名:iceskysl\nblog: http://iceskysl.1sters.com\n欢迎大家就书或者Android的问题和我们进行直接的交流。\n社区支持:http://www.eoeandroid.com/","summary":"本书内容上覆盖了用Android开发的大部分场景，从Android基础介绍、环境搭建、SDK介绍、Market使用，到应用剖析、组件介绍、实例演示等方面。从技术实现上，讲解了5个Android平台下的完整综合实例及源代码分析，分别是RSS阅读器、基于Google Map的个人GPS、豆瓣网（Web 2.0）客户端、在线音乐播放器、手机信息助手。\n本书注重对实际动手能力的指导，在遵循技术研发知识体系的严密性同时，在容易产生错误、不易理解的环节配以了详实的开发情景截图，并将重要的知识点和经验技巧以\u201c小实验\u201d、\u201c小知识\u201d的活泼形式呈现给读者。在程序实例的讲解方面，将实例安插在Android开发的精髓知识章节，这为初学者学习与实践结合提供了很好的指导。.\n本书配套有300多分钟的全程开发视频光盘，指导读者快速、无障碍地学通Android实战开发技术。..\n本书适合具备一定软件开发经验，想快速进入Android开发领域的程序员；具备一些手机开发经验的开发者和Android开发爱好者学习用书；也适合作为相关培训学校的Android培训教材。\n特点：\n* 第一本国内开发团队原创的Android图书\n* 完全基于Android最新的SDK1.5\n* 著名台湾技术专家高焕堂、Google Android工程师何峰、InfoQ站长霍泰稳鼎力推荐！\n* 全书除了大量小型案例之外还包含了5个Android平台下的完整商业实例及源码分析，分别是RSS阅读器、基于GoogleMap的个人GPS、豆瓣客户端、在线音乐播放器、手机信息助手\n* 随书附赠的光盘中包含389分钟的详细教学视频以及Android开发必备开发资源，部分教学视频免费下载地址：http://www.eoeandroid.com/viewthread.php?tid=328\n* 读者对于此书内容的疑问可以访问http://www.eoeandroid.com社区，作者团队将会及时解答","price":"55.00元"},{"rating":{"max":10,"numRaters":54,"average":"8.7","min":0},"subtitle":"","author":["罗升阳"],"pubdate":"2012-10","tags":[{"count":270,"name":"Android","title":"Android"},{"count":81,"name":"android","title":"android"},{"count":51,"name":"编程","title":"编程"},{"count":42,"name":"计算机","title":"计算机"},{"count":41,"name":"内核","title":"内核"},{"count":38,"name":"软件开发","title":"软件开发"},{"count":35,"name":"Linux","title":"Linux"},{"count":30,"name":"计算机技术","title":"计算机技术"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s27280265.jpg","binding":"平装","translator":[],"catalog":"目录\n第1篇 初识Android系统\n第1章 准备知识 2\n1.1 Linux内核参考书籍 2\n1.2 Android应用程序参考书籍 3\n1.3 下载、编译和运行Android源代码 3\n1.3.1 下载Android源代码 4\n1.3.2 编译Android源代码 4\n1.3.3 运行Android模拟器 5\n1.4 下载、编译和运行Android内核源代码 6\n1.4.1 下载Android内核源代码 6\n1.4.2 编译Android内核源代码 7\n1.4.3 运行Android模拟器  8\n1.5 开发第一个Android应用程序 8\n1.6 单独编译和打包Android应用程序模块 11\n1.6.1 导入单独编译模块的mmm命令 11\n1.6.2 单独编译Android应用程序模块 12\n1.6.3 重新打包Android系统镜像文件 12\n第２章 硬件抽象层 13\n2.1 开发Android硬件驱动程序 4\n2.1.1 实现内核驱动程序模块 14\n2.1.2 修改内核Kconfig文件 21\n2.1.3 修改内核Makefile文件 22\n2.1.4 编译内核驱动程序模块 22\n2.1.5 验证内核驱动程序模块 23\n2.2 开发C可执行程序验证Android硬件驱动程序 24\n2.3 开发Android硬件抽象层模块 26\n2.3.1 硬件抽象层模块编写规范 26\n2.3.2 编写硬件抽象层模块接口 29\n2.3.3 硬件抽象层模块的加载过程 33\n2.3.4 处理硬件设备访问权限问题 36\n2.4 开发Android硬件访问服务 38\n2.4.1 定义硬件访问服务接口 38\n2.4.2 实现硬件访问服务 39\n2.4.3 实现硬件访问服务的JNI方法 40\n2.4.4 启动硬件访问服务 43\n2.5 开发Android应用程序来使用硬件访问服务 44\n第３章 智能指针 49\n3.1 轻量级指针 50\n3.1.1 实现原理分析 50\n3.1.2 应用实例分析 53\n3.2 强指针和弱指针 54\n3.2.1 强指针的实现原理分析 55\n3.2.2 弱指针的实现原理分析 61\n3.2.3 应用实例分析 67\n第2篇 Android专用驱动系统\n第４章 Logger日志系统 74\n4.1 Logger日志格式 75\n4.2 Logger日志驱动程序 76\n4.2.1 基础数据结构 77\n4.2.2 日志设备的初始化过程 78\n4.2.3 日志设备文件的打开过程 83\n4.2.4 日志记录的读取过程 84\n4.2.5 日志记录的写入过程 88\n4.3 运行时库层日志库 93\n4.4 C/C++日志写入接口 100\n4.5 Java日志写入接口 104\n4.6 Logcat工具分析 110\n4.6.1 相关数据结构 111\n4.6.2 初始化过程 115\n4.6.3 日志记录的读取过程 127\n4.6.4 日志记录的输出过程 132\n第５章 Binder进程间通信系统 144\n5.1 Binder驱动程序 145\n5.1.1 基础数据结构 146\n5.1.2 Binder设备的初始化过程 164\n5.1.3 Binder设备文件的打开过程 165\n5.1.4 Binder设备文件的内存映射过程 166\n5.1.5 内核缓冲区管理 173\n5.2 Binder进程间通信库 183\n5.3 Binder进程间通信应用实例 188\n5.4 Binder对象引用计数技术 196\n5.4.1 Binder本地对象的生命周期 197\n5.4.2 Binder实体对象的生命周期 201\n5.4.3 Binder引用对象的生命周期 204\n5.4.4 Binder代理对象的生命周期 209\n5.5 Binder对象死亡通知机制 212\n5.5.1 注册死亡接收通知 213\n5.5.2 发送死亡接收通知 216\n5.5.3 注销死亡接收通知 221\n5.6 Service Manager的启动过程 224\n5.6.1 打开和映射Binder设备文件 226\n5.6.2 注册为Binder上下文管理者 227\n5.6.3 循环等待Client进程请求 231\n5.7 Service Manager代理对象的获取过程 238\n5.8 Service组件的启动过程 244\n5.8.1 注册Service组件 245\n5.8.2 启动Binder线程池 289\n5.9 Service代理对象的获取过程 291\n5.10 Binder进程间通信机制的Java接口 300\n5.10.1 Service Manager的Java代理对象的获取过程 300\n5.10.2 Java服务接口的定义和解析 310\n5.10.3 Java服务的启动过程 313\n5.10.4 Java服务代理对象的获取过程 320\n5.10.5 Java服务的调用过程 323\n第６章 Ashmem匿名共享内存系统 327\n6.1 Ashmem驱动程序 328\n6.1.1 基础数据结构 328\n6.1.2 匿名共享内存设备的初始化过程 330\n6.1.3 匿名共享内存设备文件的打开过程 332\n6.1.4 匿名共享内存设备文件的内存映射过程 334\n6.1.5 匿名共享内存块的锁定和解锁过程 336\n6.1.6 匿名共享内存块的回收过程 344\n6.2 运行时库cutils的匿名共享内存访问接口 345\n6.3 匿名共享内存的C++访问接口 349\n6.3.1 MemoryHeapBase 349\n6.3.2 MemoryBase 359\n6.3.3 应用实例 364\n6.4 匿名共享内存的Java访问接口 370\n6.4.1 MemoryFile 370\n6.4.2 应用实例 375\n6.5 匿名共享内存的共享原理 386\n第3篇 Android应用程序框架\n第７章 Activity组件的启动过程 392\n7.1 Activity组件应用实例 392\n7.2 根Activity组件的启动过程 398\n7.3 子Activity组件在进程内的启动过程 432\n7.4 子Activity组件在新进程中的启动过程 440\n第８章 Service组件的启动过程 443\n8.1 Service组件应用实例 443\n8.2 Service组件在新进程中的启动过程 451\n8.3 Service组件在进程内的绑定过程 463\n第９章 Android系统广播机制 486\n9.1 广播机制应用实例 487\n9.2 广播接收者的注册过程 493\n9.3 广播的发送过程 501\n第10章 Content Provider组件的实现原理 524\n10.1 Content Provider组件应用实例 525\n10.1.1 ArticlesProvider 525\n10.1.2 Article 535\n10.2 Content Provider组件的启动过程 550\n10.3 Content Provider组件的数据共享原理 573\n10.3.1 数据共享模型 573\n10.3.2 数据传输过程 576\n10.4 Content Provider组件的数据更新通知机制 596\n10.4.1 注册内容观察者 597\n10.4.2 发送数据更新通知 603\n第11章 Zygote和System进程的启动过程 611\n11.1 Zygote进程的启动脚本  611\n11.2 Zygote进程的启动过程 614\n11.3 System进程的启动过程 622\n第12章 Android应用程序进程的启动过程 630\n12.1 应用程序进程的创建过程 630\n12.2 Binder线程池的启动过程 639\n12.3 消息循环的创建过程 641\n第13章 Android应用程序的消息处理机制 645\n13.1 创建线程消息队列 645\n13.2 线程消息循环过程 650\n13.3 线程消息发送过程 655\n13.4 线程消息处理过程 660\n第14章 Android应用程序的键盘消息处理机制 667\n14.1 键盘消息处理模型  667\n14.2 InputManager的启动过程  670\n14.2.1 创建InputManager 670\n14.2.2 启动InputManager 673\n14.2.3 启动InputDispatcher 675\n14.2.4 启动InputReader 677\n14.3 InputChannel的注册过程 688\n14.3.1 创建InputChannel 689\n14.3.2 注册Server端InputChannel 697\n14.3.3 注册系统当前激活的应用程序窗口 701\n14.3.4 注册Client端InputChannel 706\n14.4 键盘消息的分发过程 709\n14.4.1 InputReader获得键盘事件 710\n14.4.2 InputDispatcher分发键盘事件 717\n14.4.3 系统当前激活的应用程序窗口获得键盘消息 727\n14.4.4 InputDispatcher获得键盘事件处理完成通知 743\n14.5 InputChannel的注销过程 746\n14.5.1 销毁应用程序窗口 747\n14.5.2 注销Client端InputChannel 756\n14.5.3 注销Server端InputChannel 758\n第15章 Android应用程序线程的消息循环模型 764\n15.1 应用程序主线程消息循环模型 765\n15.2 与界面无关的应用程序子线程消息循环模型 766\n15.3 与界面相关的应用程序子线程消息循环模型 769\n第16章 Android应用程序的安装和显示过程 778\n16.1 应用程序的安装过程 778\n16.2 应用程序的显示过程 814","pages":"830","images":{"small":"https://img3.doubanio.com/spic/s27280265.jpg","large":"https://img3.doubanio.com/lpic/s27280265.jpg","medium":"https://img3.doubanio.com/mpic/s27280265.jpg"},"alt":"https://book.douban.com/subject/19986441/","id":"19986441","publisher":"电子工业出版社","isbn10":"7121181088","isbn13":"9787121181085","title":"Android系统源代码情景分析","url":"https://api.douban.com/v2/book/19986441","alt_title":"","author_intro":"罗升阳，1984年出生，2007年毕业于浙江大学计算机系，取得学士学位，2010年毕业于上海交通大学计算机系，取得硕士学位。毕业后一直从事于互联网软件开发，并且致力于移动平台的研究，特别是对Android平台有深入的理解和研究。在国内知名IT技术社区CSDN上发表了数十篇高质量的Android系统原创性文章，并且开设博客专栏--《老罗的Android之旅》，积极与网友互动，深受大家喜爱，访问量一直居于前茅。","summary":"在内容上，本书结合使用情景，全面、深入、细致地分析Android系统的源代码，涉及到Linux内核层、硬件抽象层（HAL）、运行时库层(Runtime)、应用程序框架层(Application Framework)以及应用程序层(Application)。\n在组织上，本书将上述内容划分为初识Android系统、Android专用驱动系统和Android应用程序框架三大篇章。初识Android系统篇介绍了参考书籍、基础知识以及实验环境搭建；Android专用驱动系统篇介绍了Logger日志驱动程序、Binder进程间通信驱动程序以及Ashmem匿名共享内存驱动程序；Android应用程序框架篇从组件、进程、消息以及安装四个维度来对Android应用程序的框架进行了深入的剖析。\n通过上述内容及其组织，本书能使读者既能从整体上把握Android系统的层次结构，又能从细节上去掌握每一个层次的要点。","price":"109.00元"},{"rating":{"max":10,"numRaters":27,"average":"8.0","min":0},"subtitle":"A Learner's Guide to Creating Applications for Android Devices","author":["Jonathan Simon"],"pubdate":"2011-8-5","tags":[{"count":40,"name":"Android","title":"Android"},{"count":20,"name":"HeadFirst","title":"HeadFirst"},{"count":13,"name":"软件开发","title":"软件开发"},{"count":13,"name":"计算机","title":"计算机"},{"count":11,"name":"编程","title":"编程"},{"count":7,"name":"计算机科学","title":"计算机科学"},{"count":7,"name":"程序设计","title":"程序设计"},{"count":5,"name":"英文版","title":"英文版"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s6518051.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"608","images":{"small":"https://img3.doubanio.com/spic/s6518051.jpg","large":"https://img3.doubanio.com/lpic/s6518051.jpg","medium":"https://img3.doubanio.com/mpic/s6518051.jpg"},"alt":"https://book.douban.com/subject/6530430/","id":"6530430","publisher":"O'Reilly Media","isbn10":"1449393306","isbn13":"9781449393304","title":"Head First Android Development","url":"https://api.douban.com/v2/book/6530430","alt_title":"","author_intro":"Jonathan Simon\nJonathan Simon is a developer and interaction designer who loves to make great apps for people to use\u2014and loves to help other people make them, too. He\u2019s worked on a dizzying array of platforms and customers, from trading systems built in Java/Swing for JPMorganChase and Merrill Lynch, to collaborative websites built in Ruby on Rails, and now, mobile. Jonathan is a longtime veteran of the mobile space, developing J2ME mobile apps all the way back when the Motorola RAZR was the phone everyone had to have. Since then, he\u2019s developed mobile apps for Android, iPhone, and BlackBerry. Jonathan is currently a senior engineer at AllTrails, a Yelp for the outdoors.","summary":"With this digital Early Release edition of Head First Android Development, you get the entire book bundle in its earliest form \u2013 the author's raw and unedited content \u2013 so you can take advantage of this content long before the book's official release. You'll also receive updates when significant changes are made, as well as the final ebook version.\nAndroid devices are stealing market share from the iPhone with dramatic speed, and you have a killer app idea. Where to begin? Head First Android Development will help you get your first application up and running in no time with the Android SDK and Eclipse plug-in. You'll learn how to design for devices with a variety of different screen sizes and resolutions, along with mastering core programming and design principles that will make your app stand out.\nWhether you're a seasoned iPhone developer who wants to jump into the the Android Market, or someone with previous programming skills but no mobile apps in your resume, this book offers a complete learning experience for creating eye-catching, top-selling Android applications.\nYou'll learn how to:\nInstall the Android SDK and Eclipse plug-in and get started building apps\nAdd buttons, edit text fields, and build your own navigation options in the Android menu\nCustomize the look of your app with theming and adding image resources\nUse Android's content provider mechanism to add images and contact information to an app, and establish permissions for their use\nWork with the Android devices' camera, GPS, and accelerometer\nExperiment with different Android emulator configurations to simulate different devices with a variety of screen sizes\nOptimize, test, and distribute your application in the Android Market\nWe think your time is too valuable to waste struggling with new concepts. Using the latest research in cognitive science and learning theory to craft a multi-sensory learning experience, Head First Android Development uses a visually rich format designed for the way your brain works, not a text-heavy approach that puts you to sleep.","price":"USD 44.99"},{"rating":{"max":10,"numRaters":96,"average":"8.1","min":0},"subtitle":"","author":["丰生强"],"pubdate":"2013-2","tags":[{"count":216,"name":"Android","title":"Android"},{"count":136,"name":"安全","title":"安全"},{"count":103,"name":"逆向工程","title":"逆向工程"},{"count":43,"name":"移动开发","title":"移动开发"},{"count":30,"name":"android","title":"android"},{"count":27,"name":"计算机","title":"计算机"},{"count":24,"name":"计算机安全","title":"计算机安全"},{"count":15,"name":"编程","title":"编程"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s24870013.jpg","binding":"平装","translator":[],"catalog":"第1章 　Android程序分析环境搭建　　1\n1.1 　Windows分析环境搭建　　1\n1.1.1 　安装JDK　　1\n1.1.2 　安装Android SDK　　3\n1.1.3 　安装Android NDK　　5\n1.1.4 　Eclipse集成开发环境　　6\n1.1.5 　安装CDT、ADT插件　　6\n1.1.6 　创建Android Virtual Device　　8\n1.1.7 　使用到的工具　　9\n1.2 　Linux分析环境搭建　　9\n1.2.1 　本书的Linux环境　　9\n1.2.2 　安装JDK　　9\n1.2.3 　在Ubuntu上安装Android SDK　　10\n1.2.4 　在Ubuntu上安装Android NDK　　11\n1.2.5 　在Ubuntu上安装Eclipse集成开发环境　　12\n1.2.6 　在Ubuntu上安装CDT、ADT插件　　13\n1.2.7 　创建Android Virtual Device　　13\n1.2.8 　使用到的工具　　15\n1.3 　本章小结　　15\n第2章 　如何分析Android程序　　16\n2.1 　编写第一个Android程序　　16\n2.1.1 　使用Eclipse创建Android工程　　16\n2.1.2 　编译生成APK文件　　19\n2.2 　破解第一个程序　　20\n2.2.1 　如何动手？　　20\n2.2.2 　反编译APK文件　　20\n2.2.3 　分析APK文件　　21\n2.2.4 　修改Smali文件代码　　26\n2.2.5 　重新编译APK文件并签名　　26\n2.2.6 　安装测试　　27\n2.3 　本章小结　　28\n第3章 　进入Android Dalvik虚拟机　　29\n3.1 　Dalvik虚拟机的特点\u2014\u2014掌握Android程序的运行原理　　29\n3.1.1 　Dalvik虚拟机概述　　29\n3.1.2 　Dalvik虚拟机与Java虚拟机的区别　　29\n3.1.3 　Dalvik虚拟机是如何执行程序的　　34\n3.1.4 　关于Dalvik虚拟机JIT（即时编译）　　36\n3.2 　Dalvik汇编语言基础为分析Android程序做准备　　37\n3.2.1 　Dalvik指令格式　　37\n3.2.2 　DEX文件反汇编工具　　39\n3.2.3 　了解Dalvik寄存器　　40\n3.2.4 　两种不同的寄存器表示方法\u2014\u2014v命名法与p命名法　　42\n3.2.5 　Dalvik字节码的类型、方法与字段表示方法　　43\n3.3 　Dalvik指令集　　44\n3.3.1 　指令特点　　45\n3.3.2 　空操作指令　　45\n3.3.3 　数据操作指令　　46\n3.3.4 　返回指令　　46\n3.3.5 　数据定义指令　　46\n3.3.6 　锁指令　　47\n3.3.7 　实例操作指令　　47\n3.3.8 　数组操作指令　　48\n3.3.9 　异常指令　　48\n3.3.10 　跳转指令　　48\n3.3.11 　比较指令　　49\n3.3.12 　字段操作指令　　50\n3.3.13 　方法调用指令　　50\n3.3.14 　数据转换指令　　51\n3.3.15 　数据运算指令　　51\n3.4 　Dalvik指令集练习\u2014\u2014写一个Dalvik版的Hello World　　52\n3.4.1 　编写smali文件　　52\n3.4.2 　编译smali文件　　54\n3.4.3 　测试运行　　54\n3.5 　本章小结　　55\n第4章 　Android可执行文件　　56\n4.1 　Android程序的生成步骤　　56\n4.2 　Android程序的安装流程　　59\n4.3 　dex文件格式　　66\n4.3.1 　dex文件中的数据结构　　66\n4.3.2 　dex文件整体结构　　68\n4.3.3 　dex文件结构分析　　71\n4.4 　odex文件格式　　80\n4.4.1 　如何生成odex文件　　80\n4.4.2 　odex文件整体结构　　81\n4.4.3 　odex文件结构分析　　83\n4.5 　dex文件的验证与优化工具dexopt的工作过程　　88\n4.6 　Android应用程序另类破解方法　　91\n4.7 　本章小结　　93\n第5章 　静态分析Android程序　　94\n5.1 　什么是静态分析　　94\n5.2 　快速定位Android程序的关键代码　　94\n5.2.1 　反编译apk程序　　94\n5.2.2 　程序的主Activity　　95\n5.2.3 　需重点关注的Application类　　95\n5.2.4 　如何定位关键代码\u2014\u2014六种方法　　96\n5.3 　smali文件格式　　97\n5.4 　Android程序中的类　　100\n5.4.1 　内部类　　100\n5.4.2 　监听器　　102\n5.4.3 　注解类　　105\n5.4.4 　自动生成的类　　108\n5.5 　阅读反编译的smali代码　　110\n5.5.1 　循环语句　　110\n5.5.2 　switch分支语句　　115\n5.5.3 　try/catch语句　　121\n5.6 　使用IDA Pro静态分析Android程序　　127\n5.6.1 　IDA Pro对Android的支持　　127\n5.6.2 　如何操作　　128\n5.6.3 　定位关键代码\u2014\u2014使用IDA Pro进行破解的实例　　132\n5.7 　恶意软件分析工具包\u2014\u2014Androguard　　135\n5.7.1 　Androguard的安装与配置　　135\n5.7.2 　Androguard的使用方法　　137\n5.7.3 　使用Androguard配合Gephi进行静态分析　　144\n5.7.4 　使用androlyze.py进行静态分析　　148\n5.8 　其他静态分析工具　　152\n5.9 　阅读反编译的Java代码　　152\n5.9.1 　使用dex2jar生成jar文件　　152\n5.9.2 　使用jd-gui查看jar文件的源码　　153\n5.10 　集成分析环境\u2014\u2014santoku　　154\n5.11 　本章小结　　156\n第6章 　基于Android的ARM汇编语言基础\u2014\u2014逆向原生！　　157\n6.1 　Android与ARM处理器　　157\n6.1.1 　ARM处理器架构概述　　157\n6.1.2 　ARM处理器家族　　158\n6.1.3 　Android支持的处理器架构　　159\n6.2 　原生程序与ARM汇编语言\u2014\u2014逆向你的原生Hello ARM　　160\n6.2.1 　原生程序逆向初步　　160\n6.2.2 　原生程序的生成过程　　162\n6.2.3 　必须了解的ARM知识　　164\n6.3 　ARM汇编语言程序结构　　166\n6.3.1 　完整的ARM汇编程序　　166\n6.3.2 　处理器架构定义　　167\n6.3.3 　段定义　　168\n6.3.4 　注释与标号　　169\n6.3.5 　汇编器指令　　169\n6.3.6 　子程序与参数传递　　170\n6.4 　ARM处理器寻址方式　　170\n6.4.1 　立即寻址　　170\n6.4.2 　寄存器寻址　　171\n6.4.3 　寄存器移位寻址　　171\n6.4.4 　寄存器间接寻址　　171\n6.4.5 　基址寻址　　171\n6.4.6 　多寄存器寻址　　171\n6.4.7 　堆栈寻址　　172\n6.4.8 　块拷贝寻址　　172\n6.4.9 　相对寻址　　172\n6.5 　ARM与Thumb指令集　　173\n6.5.1 　指令格式　　173\n6.5.2 　跳转指令　　174\n6.5.3 　存储器访问指令　　175\n6.5.4 　数据处理指令　　177\n6.5.5 　其他指令　　184\n6.6 　用于多媒体编程与浮点计算的NEON与VFP指令集　　185\n6.7 　本章小结　　186\n第7章 　Android NDK程序逆向分析　　187\n7.1 　Android中的原生程序　　187\n7.1.1 　编写一个例子程序　　187\n7.1.2 　如何编译原生程序　　188\n7.2 　原生程序的启动流程分析　　194\n7.2.1 　原生程序的入口函数　　194\n7.2.2 　main函数究竟何时被执行　　198\n7.3 　原生文件格式　　199\n7.4 　原生C程序逆向分析　　200\n7.4.1 　原生程序的分析方法　　200\n7.4.2 　for循环语句反汇编代码的特点　　204\n7.4.3 　if...else分支语句反汇编代码的特点　　208\n7.4.4 　while循环语句反汇编代码的特点　　211\n7.4.5 　switch分支语句反汇编代码的特点　　215\n7.4.6 　原生程序的编译时优化　　218\n7.5 　原生C++程序逆向分析　　222\n7.5.1 　C++类的逆向　　222\n7.5.2 　Android NDK对C++特性的支持　　225\n7.5.3 　静态链接STL与动态链接STL的代码区别　　227\n7.6 　Android NDK JNI API逆向分析　　232\n7.6.1 　Android NDK提供了哪些函数　　232\n7.6.2 　如何静态分析Android NDK程序　　233\n7.7 　本章小结　　235\n第8章 　动态调试Android程序　　236\n8.1 　Android动态调试支持　　236\n8.2 　DDMS的使用　　237\n8.2.1 　如何启动DDMS　　237\n8.2.2 　使用LogCat查看调试信息　　238\n8.3 　定位关键代码　　240\n8.3.1 　代码注入法\u2014\u2014让程序自己吐出注册码　　240\n8.3.2 　栈跟踪法　　244\n8.3.3 　Method Profiling　　247\n8.4 　使用AndBug调试Android程序　　250\n8.4.1 　安装AndBug　　251\n8.4.2 　使用AndBug　　251\n8.5 　使用IDA Pro调试Android原生程序　　254\n8.5.1 　调试Android原生程序　　255\n8.5.2 　调试Android原生动态链接库　　256\n8.6 　使用gdb调试Android原生程序　　260\n8.6.1 　编译gdb与gdbserver　　260\n8.6.2 　如何调试　　262\n8.7 　本章小结　　264\n第9章 　Android软件的破解技术　　265\n9.1 　试用版软件　　265\n9.1.1 　试用版软件的种类　　265\n9.1.2 　实例破解\u2014\u2014针对授权KEY方式的破解　　265\n9.2 　序列号保护　　271\n9.3 　网络验证　　272\n9.3.1 　网络验证保护思路　　272\n9.3.2 　实例破解\u2014\u2014针对网络验证方式的破解　　273\n9.4 　In-app Billing（应用内付费）　　277\n9.4.1 　In-app Billing原理　　277\n9.4.2 　In-app Billing破解方法　　280\n9.5 　Google Play License保护　　281\n9.5.1 　Google Play License保护机制　　281\n9.5.2 　实例破解\u2014\u2014针对Google Play License方式的破解　　283\n9.6 　重启验证　　284\n9.6.1 　重启验证保护思路　　285\n9.6.2 　实例破解\u2014\u2014针对重启验证方式的破解　　285\n9.7 　如何破解其他类型的Android程序　　296\n9.7.1 　Mono for Android开发的程序及其破解方法　　296\n9.7.2 　Qt for Android开发的程序及其破解方法　　301\n9.8 　本章小结　　309\n第10章 　Android程序的反破解技术　　310\n10.1 　对抗反编译　　310\n10.1.1 　如何对抗反编译工具　　310\n10.1.2 　对抗dex2jar　　311\n10.2 　对抗静态分析　　312\n10.2.1 　代码混淆技术　　312\n10.2.2 　NDK保护　　315\n10.2.3 　外壳保护　　316\n10.3 　对抗动态调试　　316\n10.3.1 　检测调试器　　316\n10.3.2 　检测模拟器　　317\n10.4 　防止重编译　　318\n10.4.1 　检查签名　　318\n10.4.2 　校验保护　　319\n10.5 　本章小结　　320\n第11章 　Android系统攻击与防范　　321\n11.1 　Android系统安全概述　　321\n11.2 　手机ROOT带来的危害　　321\n11.2.1 　为什么要ROOT手机　　321\n11.2.2 　手机ROOT后带来的安全隐患　　322\n11.2.3 　Android手机ROOT原理　　322\n11.3 　Android权限攻击　　329\n11.3.1 　Android权限检查机制　　329\n11.3.2 　串谋权限攻击　　333\n11.3.3 　权限攻击检测　　336\n11.4 　Android组件安全　　339\n11.4.1 　Activity安全及Activity劫持演示　　340\n11.4.2 　Broadcast Receiver 安全　　343\n11.4.3 　Service安全　　345\n11.4.4 　Content Provider安全　　346\n11.5 　数据安全　　347\n11.5.1 　外部存储安全　　347\n11.5.2 　内部存储安全　　348\n11.5.3 　数据通信安全　　350\n11.6 　ROM安全　　351\n11.6.1 　ROM的种类　　352\n11.6.2 　ROM的定制过程　　352\n11.6.3 　定制ROM的安全隐患　　359\n11.6.4 　如何防范　　360\n11.7 　本章小结　　361\n第12章 　DroidKongFu变种病毒实例分析　　362\n12.1 　DroidKongFu病毒介绍　　362\n12.2 　配置病毒分析环境　　363\n12.3 　病毒执行状态分析　　364\n12.3.1 　使用APIMonitor初步分析　　365\n12.3.2 　使用DroidBox动态分析　　369\n12.3.3 　其他动态分析工具　　373\n12.4 　病毒代码逆向分析　　376\n12.4.1 　Java层启动代码分析　　376\n12.4.2 　Native层启动代码分析　　381\n12.4.3 　Native层病毒核心分析　　393\n12.5 　DroidKongFu病毒框架总结　　404\n12.6 　病毒防治　　406\n12.7 　本章小结　　406","pages":"407","images":{"small":"https://img3.doubanio.com/spic/s24870013.jpg","large":"https://img3.doubanio.com/lpic/s24870013.jpg","medium":"https://img3.doubanio.com/mpic/s24870013.jpg"},"alt":"https://book.douban.com/subject/20556210/","id":"20556210","publisher":"人民邮电出版社","isbn10":"7115308152","isbn13":"9787115308153","title":"Android软件安全与逆向分析","url":"https://api.douban.com/v2/book/20556210","alt_title":"","author_intro":"丰生强（网名非虫）\nAndroid软件安全专家。看雪论坛Android安全版版主；安卓巴士开发交流版版主。\n对Android软件与系统安全有狂热的爱好和独到的见解，对Android系统的全部源代码进行过深入地研究和分析。逆向分析实战经验丰富。\n在国内信息安全杂志上发表过多篇有价值的软件安全文章，目前就职于国内某Android开发企业，常年混迹于看雪论坛（ID非虫）。\n作者邮箱：fei_cong@hotmail.com\n愿与国内安全爱好者共同交流与探讨安全技术。","summary":"本书由浅入深、循序渐进地讲解了Android 系统的软件安全、逆向分析与加密解密技术。包括Android软件逆向分析和系统安全方面的必备知识及概念、如何静态分析Android 软件、如何动态调试Android 软件、Android 软件的破解与反破解技术的探讨，以及对典型Android 病毒的全面剖析。\n本书适合所有Android 应用开发者、Android 系统开发工程师、Android 系统安全工作者阅读学习。","series":{"id":"13000","title":"图灵原创"},"price":"69.00元"},{"rating":{"max":10,"numRaters":232,"average":"6.6","min":0},"subtitle":"","author":["杨丰盛"],"pubdate":"2010-1","tags":[{"count":172,"name":"Android","title":"Android"},{"count":62,"name":"Android开发","title":"Android开发"},{"count":32,"name":"编程","title":"编程"},{"count":27,"name":"软件开发","title":"软件开发"},{"count":27,"name":"Android应用开发揭秘","title":"Android应用开发揭秘"},{"count":25,"name":"计算机","title":"计算机"},{"count":12,"name":"移动开发","title":"移动开发"},{"count":10,"name":"mobile","title":"mobile"}],"origin_title":"","image":"https://img1.doubanio.com/mpic/s4143787.jpg","binding":"平装","translator":[],"catalog":"前言\n第一部分 准备篇\n第1章 android开发简介\n1.1 android基本概念\n1.1.1 android简介\n1.1.2 android的系统构架\n1.1.3 android应用程序框架\n1.2 oms介绍\n1.2.1 ophone介绍\n1.2.2 widget介绍\n1.3 小结\n第2章 android开发环境搭建\n2.1 android开发准备工作\n2.2 开发包及其工具的安装和\n配置\n2.2.1 安装jdk和配置java开发\n环境\n2.2.2 eclipse的安装与汉化\n2.2.3 sdk和adt的安装和\n.配置\n2.3 创建第一个android项目\u2014\u2014heuoandroid\n2.3.1 创建helloandroid项目\n2.3.2 运行helloandroid及模拟器的使用\n2.3.3 调试helloandroid\n2.4 小结\n第二部分 基础篇\n第3章 android程序设计基础\n3.1 android程序框架\n3.1.1 android项目目录结构\n3.1.2 android应用解析\n3.2 android的生命周期\n3.3 android程序u设计\n3.4 小结\n第4章 用户界面开发\n4.1 用户界面开发详解\n4.1.1 用户界面简介\n4.1.2 事件处理\n4.2 常用控件应用\n4.2.1 文本框(textiew)\n4.2.2 列表(listview)\n4.2.3 提示(t0ast)\n4.2.4 编辑框(edittext)\n4.2.5 单项选择(radiogroup、radiobutton\n4.2.6 多项选择(checkbox)\n4.2.7 下拉列表(spinner)\n4.2.8 自动提示(autocomplete.textⅵew)\n4.2.9 日期和时间(datepicker、timepicker)\n4.2.10 按钮(button)\n4.2.1l 菜单(menu)\n4.2.12 对话框(dialog)\n4.2.13 图片视图(imageview)\n4.2.14 带图标的按钮(imagebutton)\n4.2.15 拖动效果(gallery)\n4.2.16 切换图片(hmgeswilcher)\n4.2.17 网格视图(gridview)\n4.2.18 卷轴视图(scrollview)\n4.2.19 进度条(progressbar)\n4.2.20 拖动条(seekbar)\n4.2.21 状态栏提示(notification、notificationmanager)\n4.2.22 对话框中的进度条(progressdialog)\n4.3 界面布局\n4.3.1 垂直线性布局\n4.3.2 水平线性布局\n4.3.3.相对布局(relativelayout)\n4.3.4 表单布局(tablelayout)\n4.3.5 切换卡(tabwidget)\n4,4 小结\n第5章 android游戏开发\n5.1 android游戏开发框架\n5.1.1 view类开发框架\n5.1.2 surfaceview类开发框架\n5.2 graphics类开发\n5.5.1 paint和color类介绍\n5.2.2 canvas类介绍\n5.2.3 几何图形绘制\n5.2.4 字符串绘制\n5.2.5 图像绘制\n5.2.6 图像旋转\n5.2.7 图像缩放\n5.2.8 图像像素操作\n5.2.9 shader类介绍\n5.2.10 双缓冲技术\n5.2.11 全屏显示\n5.2.12 获得屏幕属性\n5.3 动画实现\n5.3.1 tween动画\n5.3.2 frame动画\n5.3.3 gif动画播放\n5.4 小结\n第6章 android数据存储\n6.1 android数据存储初探\n6.2 数据存储之shared preferences\n6.3 数据存储之files\n6.4 数据存储之network\n6.5 android数据库编程\n6.5.1 sqlite简介\n6.5.2 sqlite编程详解\n6.5.3 sqliteopenhelper应用\n6.6 数据共享(contentproviders)\n6.7 小结\n第7 章多媒体开发\n7.1 多媒体开发详解\n7.1.1 open core\n7.1.2 mediaplayer\n7.1.3 mediarecorder\n7.2 播放音乐\n7.3 播放视频\n7.4 录制歌曲\n7.5 相机设置\n7.6 闹钟设置\n7.7 铃声设置\n7.8 小结\n第8章 网络与通信\n8.1 网络通信基础\n8.1.1 无线网络技术\n8.1.2 android网络基础\n8.2 http通信\n8.2.1 httpurlconnection接口\n8.2.2 httpclient接口\n8.2.3 实时更新\n8.3 socket通信\n8.3.1 socket基础\n8.3.2 socket应用(简易聊天室)\n8.4 网络通信的中文乱码问题\n8.5 webkit应用\n8.5.1 webkjt概述\n8.5.2 webview浏览网页\n8.5.3 webview与javascript\n8.6 wtfi介绍\n8.7 蓝牙\n8.8 小结\n第9章 android特色开发\n9.1 传感器\n9.2 语音识别\n9.3 googlemap\n9.3.1 googlemap概述\n9.3.2 准备工作\n9.3.3 googlemapapi的使用\n9.3.4 定位系统\n9.4 桌面组件\n9.4.1 快捷方式\n9.4.2 实时文件夹\n9.4.3 widget开发\n9.5 账户管理\n9.6 小结\n第三部分 实例篇\n第10章 android应用开发\n实例\n10.1 情境模式\n10.2 文件管理器\n10.3 通讯录\n10.4 音乐播放器\n10.5 天气预报\n10.6 个人地图\n10.7 widget日历\n10.8 小结\n第11 章android游戏开发实例\n11.1 手机游戏开发简介\n11.2 游戏框架设计\n11.3 地图设计\n11.4 主角设计\n11.5 图层管理器\n11.6 游戏音效\n11.7 游戏存档\n11.8 小结\n第四部分 高级篇\n第12章 androidopengl开发\n基础\n12.1 opengl简介\n12.2 多边形\n12.3 颜色\n12.4 旋转\n12.5 3d 空间\n12.6 纹理映射\n12.7 光照和事件\n12.8 混合\n12.9 小结\n第13章 androidopengl综合\n应用\n13.1 移动图像\n13.2.3d 世界\n13.3 飘动的旗帜\n13.4 显示列表\n13.5 雾\n13.6 粒子系统\n13.7 蒙版\n13.8 变形\n13.9 小结\n第14章 游戏引擎实现\n14.1 游戏引擎介绍\n14.1.1 什么是引擎\n14.1.2 引擎的进化\n14.1.3 常见的游戏引擎\n14.1.4 android游戏引擎\n14.2 游戏引擎结构\n14.2.1 游戏引擎原理\n14.2.2 游戏引擎定位\n14.2.3 游戏引擎框架\n14.3 游戏引擎设计\n14.3.1 游戏引擎结构和功能\n设计\n14.3.2 游戏引擎设计注意事项\n14.4 游戏引擎实现\n14.4.1 activity类实现\n14.4.2 流程控制和线程\n14.4.3 游戏对象与对象管理\n14.4.4 图形引擎\n14.4.5 物理引擎\n14.4.6 事件模块\n14.4.7 工具模块\n14.4.8 脚本引擎、音效模块、网络\n模块\n14.5 小结\n第15章 优化技术\n15.1 优化的基本知识\n15.1.1 如何书写出优秀代码\n15.1.2 编程规范\n15.2 程序性能测试\n15.2.1 计算性能测试\n15.2.2 内存消耗测试\n15.3 初级优化\n15.4 高级优化\n15.5 android高效开发\n15.6 androidui优化\n15.7 其他优化\n15.7.1 zipalign\n15.7.2 图片优化\n15.8 小结\n第五部分 扩展篇\n第16章 android ndk开发\n16.1 androidndk简介\n16.2 安装和配置ndk开发环境\n16.2.1 系统和软件需求\n16.2.2 ndk开发环境搭建\n16.2.3 编译第一个ndk程序\n16.3 androidndk开发\n16.3.1 jni接口设计\n16.3.2 使用c\\c++实现本地\n方法\n16.3.3 android.mk实现\n16.3.4 application.mk实现\n16.3.5 编译c\\c++代码\n16.4 androidndk中使用0pengl\n16.5小结\n第17章 android脚本环境\n17.1 android脚本环境简介\n17.2 android脚本环境安装\n17.3如何编写android脚本程序\n17.4小结","ebook_url":"https://read.douban.com/ebook/15091353/","pages":"515","images":{"small":"https://img1.doubanio.com/spic/s4143787.jpg","large":"https://img1.doubanio.com/lpic/s4143787.jpg","medium":"https://img1.doubanio.com/mpic/s4143787.jpg"},"alt":"https://book.douban.com/subject/4200822/","id":"4200822","publisher":"机械工业出版社","isbn10":"7111291956","isbn13":"9787111291954","title":"Android应用开发揭秘","url":"https://api.douban.com/v2/book/4200822","alt_title":"","author_intro":"Android应用开发先驱，对Android有深入研究，实战经验极其丰富。精通Java、C、C++等语言，专注于移动通信软件开发，在机顶盒软件开发和MTK平台软件开发方面有非常深厚的积累。2007年获得中国软件行业协会游戏软件分会(CGIA)认证及国际游戏开发教育联合会国际认证。曾经领导和参与《三国群英传说》、《大航海传奇》、《美少女养成计划》等经典游戏的开发。","summary":"内容简介：\n阿国内第一本基于Android 2.0的经典著作，5大专业社区联袂推荐，权威性毋庸置疑！\n本书内容全面，不仅详细讲解了Android框架、Android组件、用户界面开发、游戏开发、数据存储、多媒体开发和网络开发等基础知识，而且还深入阐述了传感器、语音识别、桌面组件开发、Android游戏引擎设计、Android应用优化、OpenGL等高级知识，最重要的是还全面介绍了如何利用原生的C/C++（NDK）和Python、Lua等脚本语言（Android Scripting Environment）来开发Android应用；本书实战性强，书中的每个知识点都有配精心设计的示例，尤为值得一提的是，它还以迭代的方式重现了各种常用的Android应用和经典Android游戏的开发全过程，既可以以它们为范例进行实战演练，又可以将它们直接应用到实际开发中去。\nWindows操作系统的诞生成就了微软的霸主地位，也造就了PC时代的繁荣。然而，以Android和iPhone手机为代表的智能移动设备的发明却敲响了PC时代的丧钟！移动互联网时代（3G时代）已经来临，谁会成为这些移动设备上的主宰？毫无疑问，它就是Android\u2014\u2014PC时代的Windows！\n移动互联网还是一个新生的婴儿，各种移动设备上的操作系统群雄争霸！与Symbian、iPhone OS、Windows Mobile相比，Android有着天生的优势\u2014\u2014完全开放和免费，对广大开发者和手机厂商而言，这是何等的诱人！此外，在Google和以其为首的Android手机联盟的大力支持和推广下，Android不仅得到了全球开发者社区的关注，而且一大批世界一流的手机厂商都已经或准备采用Android。\n拥抱Android开发，拥抱移动开发的未来！\n如果你在思考下面的问题，也许本书就是你想要的：\n·Android开发与传统的J2ME开发有何相似与不同？\n·如何通过Shared Preferences、Files、Network和SQLite等方式高效实现Android数据的存储？又如何通过Content Providers轻松地实现Android数据的共享？\n·如何使用Open Core、MediaPlayer、MediaRecorder方便快速地开发出包含音频和视频等流媒体的丰富多媒体应用？\n·如何利用Android 2.0中新增的蓝牙特性开发包含蓝牙功能的应用？又如何使用蓝牙API来完善应用的网络功能？\n·如何解决Android网络通信中的乱码问题？\n·在Android中如何使用语音服务和 Google Map API？Android如何访问摄像头、传感器等硬件的API？\n·如何进行Widget开发？如何用各种Android组件来打造漂亮的UI界面？\n·Android如何解析XML数据？又如何提高解析速度和减少对内存、CPU资源的消耗？\n·如何使用OpenGL ES在Android平台上开发出绚丽的3D应用？在Android平台上如何更好地设计和实现游戏引擎？\n·如何对Android应用进行优化？如何进行程序性能测试？如何实现UI、zipalign和图片优化？\n·如何通过NDK利用C、C++以及通过ASE利用Python等脚本语言开发Android应用？","ebook_price":"25.00","price":"69.00元"},{"rating":{"max":10,"numRaters":10,"average":"7.4","min":0},"subtitle":"（基于Google发布的Jelly Bean原始代码，讲述Android系统的内部静态结构关系和内部运行机制，为你呈现原汁原味的Android代码分析大餐！）","author":["杨长刚"],"pubdate":"2013-1","tags":[{"count":24,"name":"Android","title":"Android"},{"count":4,"name":"程序设计","title":"程序设计"},{"count":3,"name":"源码分析","title":"源码分析"},{"count":3,"name":"android","title":"android"},{"count":2,"name":"计算机","title":"计算机"},{"count":2,"name":"编程","title":"编程"},{"count":1,"name":"软件开发","title":"软件开发"},{"count":1,"name":"计算机技术","title":"计算机技术"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s24929890.jpg","binding":"","translator":[],"catalog":"第1章  智能指针\t1\n1.1  智能指针概述\t1\n1.2  引用计数基类RefBase\t2\n1.3  轻量级引用计数LightRefBase\t3\n1.4  强指针\t3\n1.4.1  强指针变量的初始化与生命周期\t3\n1.4.2  赋值操作与引用计数变化\t5\n1.5  弱指针\t5\n第2章  消息队列与线程处理\t7\n2.1  消息队列处理模型的设计\t7\n2.2  消息队列与线程处理的Java实现\t9\n2.2.1  Thread/Runnable\t9\n2.2.2  Message\t10\n2.2.3  MessageQueue概述\t11\n2.2.4  Handler\t11\n2.2.5  Looper\t12\n2.2.6  再论Handler\t15\n2.2.7  对同步消息的支持\t16\n2.3  native层的Looper与消息队列处理\t19\n2.3.1  Looper中的睡眠等待与唤醒机制\t19\n2.3.2  Looper对文件描述符的监控与处理\t22\n2.3.3  Looper中的消息队列处理机制\t25\n2.3.4  Looper与线程执行上下文\t27\n第3章  Binder IPC及其应用\t29\n3.1  Binder IPC\t29\n3.1.1  Binder IPC与系统服务\t29\n3.1.2  Binder类结构与调用关系\t31\n3.1.3  模板函数interface_cast的背后\t33\n3.1.4  例子AudioPolicyService\t37\n3.2  Java层对Binder的封装\t40\n3.2.1  例子IMediaPlaybackService\t42\n3.2.2  例子PhoneStateListener\t47\n3.3  大内存块的跨进程共享\t52\n3.3.1  概述\t52\n3.3.2  调用接口\t53\n3.3.3  设备空间的映射\t55\n3.3.4  Server侧的处理\t57\n第4章  HAL硬件抽象层\t59\n4.1  HAL概述\t59\n4.2  硬件模块库的通用写法\t60\n4.3  硬件模块库的装载与解析\t63\n4.4  例子Lights\t65\n4.5  例子Camera\t68\n4.6  例子Power和Vibrator\t69\n第5章  Android的启动过程\t71\n5.1  Android初始化语言及解析\t71\n5.1.1  Action\t71\n5.1.2  触发器trigger\t72\n5.1.3  命令Command\t72\n5.1.4  服务Service\t74\n5.1.5  .rc文件的解析\t76\n5.2  BootChart\t82\n5.3  ueventd守护进程\t82\n5.4  init进程的启动过程\t87\n5.5  init.rc文件中的服务进程\t93\n5.6  system_server进程\t95\n5.6.1  app_process程序\t95\n5.6.2  system_server进程\t96\n第6章  输入系统\t99\n6.1  输入系统概述\t99\n6.2  读线程\t101\n6.2.1  EventHub\t101\n6.2.2  InputReader\t106\n6.2.3  InputDevice\t108\n6.2.4  InputMapper\t108\n6.2.5  QueuedInputListener\t111\n6.3  分发线程\t112\n6.3.1  InputDispatcher\t112\n6.3.2  InputChannel\t116\n6.4  输入系统的开启\t118\n第7章  MassStorage\t121\n7.1  MassStorage概述\t121\n7.2  MountService\t122\n7.3  库libsysutils.so\t123\n7.3.1  SocketListener\t123\n7.3.2  FrameworkListener\t126\n7.3.3  NetlinkListener\t127\n7.4  守护进程vold\t128\n7.4.1  NetlinkManager\t128\n7.4.2  CommandListener\t131\n7.4.3  vold的main函数\t135\n第8章  Sensor\t137\n8.1  Sensor概述\t137\n8.2  SDK API概述\t138\n8.3  Sensor管理器\t139\n8.3.1  Sensor采样数据的获取与处理\t141\n8.3.2  SensorEventQueue\t146\n8.4  SensorService\t147\n8.4.1  逻辑传感器\t149\n8.4.2  物理传感器\t150\n8.4.3  Sensor HAL\t150\n第9章  RIL\t153\n9.1  RIL概述\t153\n9.2  rild守护进程\t154\n9.3  事件处理与分发线程\t158\n9.3.1  分发线程中的事件处理\t158\n9.3.2  RIL请求的接收与处理\t161\n9.3.3  RIL响应的回送\t165\n9.4  radiooptions工具程序\t169\n9.5  RILJ\t169\n9.5.1  RILJ概述\t169\n9.5.2  RILRequest的发送过程\t171\n9.5.3  Response的处理过程\t174\n第10章  com.android.phone进程\t178\n10.1  层次状态机StateMachine\t178\n10.2  GSMPhone\t179\n10.3  GsmCallTracker\t184\n10.3.1  GsmDataConnectionTracker\t186\n10.3.2  GsmServiceStateTracker\t188\n10.3.3  DefaultPhoneNotifier\t188\n10.3.4  其他\t189\n10.4  进程com.android.phone\t190\n第11章  Graphic\t196\n11.1  Graphic概述\t196\n11.2  Java层简介\t197\n11.2.1  SurfaceSession\t198\n11.2.2  Surface\t198\n11.2.3  SurfaceView\t199\n11.2.4  TextureView\t200\n11.3  JNI层简介\t200\n11.4  SKIA库简介\t201\n11.5  库libgui.so\t202\n11.5.1  概述\t202\n11.5.2  ComposerService\t204\n11.5.3  共享控制块surface_flinger_cblk_t\t204\n11.5.4  ISurfaceComposer\t205\n11.5.5  ScreenshotClient\t207\n11.5.6  SurfaceComposerClient\t207\n11.5.7  Surface\t210\n11.5.8  SurfaceControl\t211\n11.5.9  绘图操作的前后过程\t213\n11.5.10  SurfaceTexture Client\t215\n11.6  SurfaceFlinger进程\t222\n11.6.1  图层\t223\n11.6.2  DisplayHardware简介\t228\n11.6.3  HWComposer简介\t228\n11.6.4  VSync\t229\n11.7  库libui.so简介\t247\n11.7.1  GraphicBuffer\t247\n11.7.2  FramebufferNativeWindow\t248\n11.8  RenderScript简介\t249\n第12章  OpenGL ES软件层次栈\t250\n12.1  Android中的OpenGL ES简介\t250\n12.2  Android中OpenGL软件层次栈\t251\n12.3  包裹库与hook钩子\t253\n12.3.1  libGLESv1_CM.so包裹库\t253\n12.3.2  libGLESv2包裹库\t257\n12.3.3  libEGL包裹库\t257\n12.3.4  结构体egl_t和gl_hooks_t钩子\t258\n12.4  OpenGL实现库的加载和解析\t260\n12.4.1  加载和解析的发起\t260\n12.4.2  库装载器Loader\t261\n12.5  libGLES_android库和ETC1简介\t265\n第13章  Multimedia\t267\n13.1  Multimedia概述\t267\n13.2  API类简述\t268\n13.3  多媒体播放（playback）\t270\n13.3.1  播放流程\t273\n13.3.2  来自server侧的消息事件通知\t277\n13.4  多媒体录制（Recording）\t279\n13.5  元数据（MetaData）获取\t281\n13.6  Camera\t284\n13.6.1  Camera概述\t284\n13.6.2  CameraHardwareInterface与HAL层\t287\n13.7  Camera事件通知机制\t289\n第14章  Audio\t293\n14.1  Audio概述\t293\n14.2  Audio播放AudioTrack\t295\n14.2.1  共享控制块audio_track_cblk_t\t296\n14.2.2  数据的写入\t298\n14.2.3  事件的回送及处理\t299\n14.3  Auido录音Recording\t301\n14.3.1  录音的开始过程\t303\n14.3.2  录音的停止过程\t306\n14.4  AudioFlinger\t307\n14.4.1  AudioFlinger概述\t307\n14.4.2  Track相关类概述\t308\n14.4.3  AudioFlinger中的线程\t311\n14.5  音效AudioEffect\t319\n14.5.1  EffectHandle\t320\n14.5.2  音效引擎的封装EffectModule\t320\n14.5.3  音效链EffectChain\t321\n14.5.4  音效处理引擎接口effect_interface_s\t322\n14.5.5  音效引擎库audio_effect_library_s\t323\n14.5.6  音效引擎工厂EffectFactory\t324\n14.6  音频策略服务AudioPolicyService\t326\n第15章  Stagefright\t331\n15.1  Stagefright概述\t331\n15.2  节点子类\t332\n15.3  StagefrightPlayer\t334\n15.4  视频帧的渲染输出AwesomeRenderer\t343\n15.4.1  Renderer的创建\t344\n15.4.2  AwesomeLocalRenderer\t345\n15.4.3  AwesomeNativeWindowRenderer\t347\n15.5  AudioPlayer\t347\n15.6  A/V同步简介\t350\n15.7  StagefrightRecorder\t351\n第16章  OMXCodec\t356\n16.1  OpenMAX概述\t356\n16.1.1  组件（Component）与端口（Port）\t357\n16.1.2  组件的初始化\t358\n16.1.3  数据处理\t359\n16.1.4  组件命令OMX_Command\t360\n16.2  OMXCodec类\t362\n16.2.1  组件的创建\t362\n16.2.2  缓冲区的分配\t364\n16.2.3  数据处理流程\t370\n16.3  IOMX\t374\n16.4  OMX插件\t376\n16.4.1  平台厂家插件\t377\n16.4.2  软件OMX插件SoftOMXPlugin\t379\n16.5  组件消息的上报\t383\n第17章  GPS\t386\n17.1  GPS 简述\t386\n17.2  SDK API概述\t386\n17.3  LocationManagerService\t388\n17.4  GpsLocationProvider\t390\n17.4.1  初始化代码分析\t391\n17.4.2  消息处理与回调结构体\t392\n17.4.3  例子：位置信息的上报\t394\n17.5  HAL层简介\t396\n17.5.1  GPS的位置信息\t396\n17.5.2  GPS卫星信息\t397\n17.5.3  GPS回调函数\t397\n第18章  NFC\t399\n18.1  NFC概述\t399\n18.2  SDK API概述\t400\n18.2.1  NfcAdapter\t401\n18.2.2  NdefMessage\t401\n18.2.3  NFC Tag\t402\n18.2.4  NFC-extras\t403\n18.3  进程com.android.nfc\t403\n18.3.1  P2pEventManager\t403\n18.3.2  P2pLinkManager\t405\n18.3.3  Bluetooth Handover\t408\n18.3.4  SNEP\t409\n18.3.5  NDEF Push\t413\n18.3.6  其他类简介\t414\n18.4  JNI层\t415\n第19章  USB\t418\n19.1  SDK API概述\t418\n19.2  UsbService\t420\n19.2.1  UsbDeviceManager\t421\n19.2.2  UsbHostManager\t422\n19.3  uevent\t424\n第20章  Bluetooth和Wi-Fi简析\t429\n20.1  Bluetooth\t429\n20.1.1  Bluetooth概述\t429\n20.1.2  SDK API概述\t430\n20.1.3  Bluetooth服务\t432\n20.1.4  JNI层\t433\n20.2  Wi-Fi\t436\n20.2.1  Wi-Fi概述\t436\n20.2.2  SDK API概述\t436\n20.2.3  JNI和HAL层\t439\n20.2.4  WPA_supplicant\t440\n第21章  Debuggerd\t441\n21.1  预备知识\t441\n21.1.1  ptrace调用\t441\n21.1.2  waitpid\t442\n21.2  debuggerd守护进程\t442\n后记\t450","pages":"449","images":{"small":"https://img3.doubanio.com/spic/s24929890.jpg","large":"https://img3.doubanio.com/lpic/s24929890.jpg","medium":"https://img3.doubanio.com/mpic/s24929890.jpg"},"alt":"https://book.douban.com/subject/20563257/","id":"20563257","publisher":"","isbn10":"7121193744","isbn13":"9787121193743","title":"深入剖析Android系统","url":"https://api.douban.com/v2/book/20563257","alt_title":"","author_intro":"杨长刚，2005年春毕业于西南交通大学计算机应用技术专业，获硕士学位；后进入手机行业从事Linux手机软件开发工作。目前在一家欧美企业从事Android方面的技术工作。作者官方博客：http://www.redwolf-blog.com/","summary":"《深入剖析Android系统》以Android Jelly Bean（4.1）的代码为蓝本，对Android的部分关键代码进行了注释分析，并辅以大量插图，讲述了Android大部分子系统中的模块和类的静态结构，让读者对Android系统的内部静态结构有着\u201c类\u201d粒度这一层级上的认识和了解。同时，也对关键类和函数的代码调用流程、运行时刻所位于的进程和线程上下文等动态运行场景进行了分析讲述，让读者深刻理解Android系统内部是如何运行的。《深入剖析Android系统》直接对Source Insight进行截图，保留了代码的原始行号、英文注释等信息并进行了高亮显示，方便读者阅读；代码中同时添加了作者所做的中文注释说明。","price":"59.00元"},{"rating":{"max":10,"numRaters":83,"average":"8.0","min":0},"subtitle":"","author":["柯元旦"],"pubdate":"2011-9","tags":[{"count":151,"name":"Android","title":"Android"},{"count":99,"name":"Android内核","title":"Android内核"},{"count":39,"name":"Android、内核剖析、输入法框架分析、窗口管理系统、编译系","title":"Android、内核剖析、输入法框架分析、窗口管理系统、编译系"},{"count":28,"name":"内核剖析","title":"内核剖析"},{"count":22,"name":"Android,","title":"Android,"},{"count":21,"name":"android","title":"android"},{"count":20,"name":"框架","title":"框架"},{"count":20,"name":"操作系统","title":"操作系统"}],"origin_title":"","image":"https://img3.doubanio.com/mpic/s6937206.jpg","binding":"","translator":[],"catalog":"第1部分 基础篇\n第1章 linux基础\t2\n1.1 linux文件系统概述\t2\n1.2 linux启动过程\t4\n1.3 常用linux 命令\t6\n1.4 shell脚本备忘\t9\n1.4.1 获取输入\t10\n1.4.2 变量定义\t10\n1.4.3 条件判断\t11\n1.4.4 while []...do... done语句\t12\n1.4.5 for循环\t13\n1.4.6 函数\t14\n1.4.7 常用内置符号常量\t15\n1.5 make脚本备忘\t15\n1.5.1 一个简单的makefile文件\t16\n1.5.2 变量的定义与赋值\t18\n1.5.3 条件控制语句\t18\n1.5.4 宏（函数）定义\t19\n1.5.5 内置符号和变量\t22\n1.5.6 模板目标（pattern target）\t23\n1.5.7 目标特定的变量赋值（target-specific variable）\t24\n1.5.8 常用选项\t25\n第2章 java基础\t26\n2.1 类装载器dexclassloader\t26\n2.1.1 dexclassloader的调用方法\t27\n2.1.2 基于类装载器设计一种\u201c插件\u201d架构\t29\n2.2 jni调用机制\t32\n2.2.1 java访问c\t33\n2.2.2 c访问java\t35\n2.2.3 在c中使用持久对象\t37\n2.3 异步消息处理线程\t37\n2.3.1 实现异步线程的一般思路\t38\n2.3.2 android中异步线程的实现方法\t38\n第3章 android源码下载及开发环境配置\t44\n3.1 mac系统的配置\t44\n3.1.1 硬盘格式的配置\t44\n3.1.2 port的用法\t46\n3.2 在linux中配置usb连接\t46\n3.3 在eclipse中调试framework\t46\n3.3.1 一段防止下载异常的脚本\t47\n3.3.2 调试framework中的代码\t47\n第4章 使用git\t51\n4.1 安装git\t52\n4.2 git仓库管理\t52\n4.2.1 仓库的组成\t52\n4.2.2 创建仓库\t54\n4.2.3 分支管理\t55\n4.3 git merge用法\t57\n4.4 git rebase用法\t58\n4.5 git cherry-pick用法\t61\n4.6 git reset用法\t62\n4.7 恢复到无引用提交\t63\n4.8 git remote用法\t65\n4.9 git 配置\t67\n4.9.1 基本信息配置\t68\n4.9.2 merge、diff工具配置\t68\n4.9.3 .gitignore配置\t70\n4.10 同时使用git和svn\t71\n4.11 其他git常用命令示例\t72\n4.11.1 git branch\t72\n4.11.2 git checkout\t72\n4.11.3 git log\t73\n4.11.4 git commit --amend\t73\n4.11.5 git cherry-pick sha-1\t73\n4.11.6 git merge-base\t74\n4.11.7 git diff master\u2026dev\t74\n4.11.8 git revert\t75\n4.11.9 git diff\t75\n4.11.10 git rm\t75\n4.11.11 git tag\t76\n第2部分 内核篇\n第5章 binder\t78\n5.1 binder框架\t78\n5.2 设计servier端\t80\n5.3 binder客户端设计\t81\n5.4 使用service类\t82\n5.4.1 获取binder对象\t82\n5.4.2 保证包裹内参数顺序aidl工具的使用\t83\n5.5 系统服务中的binder对象\t88\n5.5.1 servicemanager管理的服务\t88\n5.5.2 理解manager\t90\n第6章 framework概述\t92\n6.1 framework框架\t92\n6.1.1 服务端\t92\n6.1.2 客户端\t93\n6.1.3 linux驱动\t94\n6.2 apk程序的运行过程\t94\n6.3 客户端中的线程\t94\n6.4 几个常见问题\t95\n6.4.1 acitivity之间如何传递消息（数据）\t95\n6.4.2 窗口相关的概念\t96\n第7章 理解context\t98\n7.1 context是什么\t98\n7.2 一个应用程序中包含多少个context对象\t99\n7.3 context相关类的继承关系\t99\n7.4 创建context\t100\n7.4.1 application对应的context\t101\n7.4.2 activity对应的context\t102\n7.4.3 service对应的context\t103\n7.4.4 context之间的关系\t104\n第8章 创建窗口的过程\t106\n8.1 窗口的类型\t106\n8.2 token变量的含义\t108\n8.2.1 activity中的mtoken\t108\n8.2.2 window中的mapptoken\t109\n8.2.3 windowmanager.layoutparams中的token\t109\n8.2.4 view中的token\t110\n8.3 创建应用窗口\t111\n8.4 创建子窗口\t121\n8.4.1 dialog的创建\t122\n8.4.2 popupwindow的创建\t126\n8.4.3 contextmenu的创建\t127\n8.4.4 optionmenu的创建\t132\n8.5 系统窗口toast的创建\t136\n8.5.1 toast调用流程\t137\n8.5.2 toast添加窗口\t139\n8.6 创建窗口示例\t139\n第9章 framework的启动过程\t142\n9.1 framework运行环境综述\t142\n9.2 dalvik虚拟机相关的可执行程序\t143\n9.2.1 dalvikvm\t144\n9.2.2 dvz\t144\n9.2.3 app_process\t145\n9.3 zygote的启动\t147\n9.3.1 在init.rc中配置zygote启动参数\t147\n9.3.2 启动socket服务端口\t148\n9.3.3 加载preload-classes\t151\n9.3.4 加载preload-resources\t152\n9.3.5 使用folk启动新的进程\t152\n9.4 systemserver进程的启动\t155\n9.4.1 启动各种系统服务线程\t156\n9.4.2 启动第一个activity\t158\n第10章 ams内部原理\t160\n10.1 activity调度机制\t160\n10.1.1 几个重要概念\t161\n10.1.2 ams中的一些重要调度相关变量\t163\n10.1.3 startactivity()的流程\t165\n10.1.4 stopactivitylocked()停止activity\t183\n10.1.5 按\u201chome\u201d键回到桌面的过程\t186\n10.1.6 按\u201cback\u201d键回到上一个activity\t187\n10.1.7 长按\u201chome\u201d键\t189\n10.1.8 activity生命期的代码含义\t190\n10.2 内存管理\t192\n10.2.1 关闭而不退出\t192\n10.2.2 android与linux的配合\t194\n10.2.3 各种关闭程序的过程\t196\n10.2.4 释放内存详解\t197\n10.3 对ams中数据对象的理解\t211\n10.3.1 常见的对象操作\t212\n10.3.2 理解activity\t213\n10.3.3 android多进程吗，是同时在运行多个应用程序吗\t213\n10.4 activitygroup的内部机制\t214\n10.4.1 tabactivity使用时的类关系结构\t215\n10.4.2 localactivitymanager的内部机制\t217\n10.4.3 activitygroup内部的activity生命期控制\t220\n第11章 从输入设备中获取消息\t221\n11.1 android消息获取过程概述\t221\n11.2 与消息处理相关的源码文件分布\t223\n11.3 创建inputdispatcher线程\t226\n11.4 把窗口信息传递给inputdispatcher线程\t227\n11.5 创建inputchannel\t229\n11.6 在wms中注册inputchannel\t232\n11.7 在客户进程中注册inputchannel\t233\n11.8 wms中处理消息的时机\t234\n11.9 客户窗口获取消息的时机\t235\n第12章 屏幕绘图基础\t237\n12.1 绘制屏幕的软件架构\t237\n12.2 java客户端绘制调用过程\t239\n12.3 c客户端绘制过程\t241\n12.4 java客户端绘制相关类的关系\t244\n第13章 view工作原理\t247\n13.1 导论\t247\n13.2 用户消息类型\t249\n13.2.1 按键消息\t249\n13.2.2 触摸消息\t250\n13.3 按键消息派发过程\t252\n13.3.1 keyevent.dispatcherstate中的长按监测\t252\n13.3.2 按键消息总体派发过程\t254\n13.3.3 根视图内部派发过程\t256\n13.3.4 activity内部派发过程\t257\n13.3.5 view类内部的onkeydown()和onkeyup()\t260\n13.3.6 activity中的onkeydown()和onkeyup()\t261\n13.3.7 phonewindow内部消息派发过程\t262\n13.4 按键消息在wms中的派发过程\t263\n13.5 触摸消息派发过程\t266\n13.5.1 触摸消息总体派发过程\t266\n13.5.2 根视图内部消息派发过程\t267\n13.5.3 viewgroup内部消息派发过程\t268\n13.5.4 各种消息监测的基本实现方法\t271\n13.5.5 view内默认消息派发过程\t272\n13.6 导致view树重新遍历的时机\t274\n13.6.1 状态的分类\t274\n13.6.2 导致view树重新遍历的总体诱因图\t275\n13.6.3 refreshdrawablelist()\t276\n13.6.4 onfocusedchanged()\t278\n13.6.5 ensuretouchmode()\t279\n13.6.6 setvisibility()\t282\n13.6.7 setenable()\t284\n13.6.8 setselected()\t285\n13.6.9 invalidate()\t286\n13.6.10 requestfocus()\t290\n13.6.11 requestlayout()\t292\n13.7 遍历view树performtraversals()的执行过程\t293\n13.8 计算视图大小（measure）的过程\t296\n13.8.1 measure内部设计思路\t297\n13.8.2 viewgroup中的measurechildwithmargins()\t301\n13.8.3 linearlayout中的onmeasure()过程举例\t304\n13.9 布局（layout）过程\t308\n13.9.1 layout过程的设计思路\t308\n13.9.2 linearlayout中onlayout()内部过程\t309\n13.9.3 textview中gravity与layout的关系\t311\n13.10 绘制（draw）过程\t313\n13.10.1 视图中可绘制的元素\t313\n13.10.2 绘制过程的设计思路\t314\n13.10.3 viewroot中draw()的内部流程\t315\n13.10.4 view类中draw()函数内部流程\t318\n13.10.5 viewgroup类中绘制子视图dispatchdraw()内部流程\t322\n13.10.6 viewgroup类中drawchild()过程\t325\n13.10.7 绘制滚动条\t328\n13.11 动画的绘制\t331\n13.11.1 动画的设计思路\t332\n13.11.2 viewgroup类中drawchild()函数中视图动画绘制过程\t334\n13.11.3 viewgroup中dipsatchdraw()中布局动画绘制流程\t337\n第14章 wms工作原理\t340\n14.1 概述\t340\n14.1.1 窗口的定义\t340\n14.1.2 窗口管理要解决的核心问题\t341\n14.1.3 解决核心问题所使用的相关的变量列表\t343\n14.1.4 几个操作的概念\t346\n14.1.5 什么是policy，以及其与wms的关系\t346\n14.1.6 wms接口结构\t347\n14.2 wms主要内部类\t348\n14.2.1 表示窗口的数据类\t348\n14.2.2 dimanimator\t348\n14.2.3 fadeinoutanimation\t349\n14.2.4 inputmonitor类\t350\n14.2.5 policythread\t351\n14.2.6 session\t352\n14.2.7 watermark\t353\n14.2.8 wmthread\t354\n14.3 窗口的创建和删除\t355\n14.3.1 创建窗口的时机和过程\t355\n14.3.2 assignlayerslocked()的执行过程\t360\n14.3.3 addwindowtolistinorderlocked()的执行过程\t362\n14.3.4 删除窗口的时机\t364\n14.3.5 删除窗口的过程\t366\n14.3.6 removewindowinnerlocked()\t367\n14.4 计算窗口的大小\t371\n14.4.1 描述窗口尺寸的变量\t371\n14.4.2 窗口大小的变化过程\t372\n14.4.3 policy中layoutwindowlw()的执行过程\t375\n14.4.4 输入法窗口如何影响应用窗口的大小\t378\n14.5 切换窗口\t379\n14.5.1 切换要解决的问题\t379\n14.5.2 inputmanager和wms的接口\t381\n14.5.3 ams与wms的接口\t383\n14.5.4 从a到b的切换\t387\n14.5.5 从b回到a的过程\t390\n14.5.6 a中长按\u201chome\u201d键切换到b\t391\n14.5.7 setappvisiblity()与销毁surface\t393\n14.5.8 computefocusedwindowlocked()\t396\n14.6 perforlayoutandplacesurfaceslockedinner()的执行过程\t398\n14.6.1 总体过程\t399\n14.6.2 第一大步骤：计算窗口的大小\t401\n14.6.3 第二大步骤：计算窗口的可视状态\t401\n14.6.4 第三大步骤：通知surfaceflinger进行窗口重绘\t404\n14.7 窗口动画\t406\n14.8 屏幕旋转及configuration的变化过程\t409\n第3部分 系统篇\n第15章 资源访问机制\t414\n15.1 定义资源\t414\n15.2 存储资源\t415\n15.3 styleable、style、attr、theme的意义\t417\n15.4 attributeset与typedarray类\t420\n15.5 获取resources的过程\t425\n15.5.1 通过context获取\t425\n15.5.2 通过packagemanager获取\t429\n15.6 framework资源\t431\n15.6.1 加载和读取\t432\n15.6.2 添加\t434\n15.6.3 实现真正主题切换的两种思路\t436\n第16章 程序包管理（package manager service）\t439\n16.1 包管理概述\t439\n16.2 packages.xml文件格式\t442\n16.2.1 last-platform-version标签\t443\n16.2.2 permissions标签\t443\n16.2.3 cert标签\t444\n16.2.4 sigs标签\t444\n16.2.5 perms标签\t444\n16.2.6 package标签\t444\n16.2.7 shared-user标签\t445\n16.3 包管理服务的启动过程\t446\n16.3.1 各主要功能类的关系\t446\n16.3.2 pms主体启动过程\t448\n16.3.3 readpermission()内部过程\t450\n16.3.4 msettings.readlp()\t452\n16.3.5 scanpackageli()内部过程\t454\n16.3.6 msettings.writelp()\t455\n16.4 应用程序的安装和卸载\t455\n16.4.1 各主要功能类关系\t456\n16.4.2 应用程序安装过程\t457\n16.4.3 应用程序的卸载过程\t461\n16.5 intent匹配框架\t463\n16.5.1 主要功能类的关系\t463\n16.5.2 主体调用过程\t465\n第17章 输入法框架\t467\n17.1 输入法框架组成概述\t468\n17.2 输入法中各binder对象的创建过程\t469\n17.2.1 inputconnection\t469\n17.2.2 iinputmethodclient\t471\n17.2.3 inputmethodsession\t472\n17.2.4 inputmethod\t475\n17.3 输入法主要操作过程\t477\n17.3.1 输入法相关模块的启动过程\t477\n17.3.2 切换输入法\t478\n17.3.3 启动输入法\t480\n17.3.4 显示输入法\t485\n17.3.5 输入法操作过程中的重要变量总结\t489\n17.4 输入法窗口内部的显示过程\t490\n17.4.1 ims中的showwindow()的内部执行过程\t491\n17.4.2 标准布局的ims\t496\n17.4.3 自定义布局的ims\t502\n17.5 向编辑框传递字符\t503\n17.6 输入法相关源码清单\t504\n第4部分 编译篇\n第18章 android编译系统\t508\n18.1 android源码文件结构\t509\n18.2 从调用make命令开始说起\t509\n18.2.1 编译命令\t510\n18.2.2 编译结构猜想\t510\n18.3 编译所需脚本文件之间的协同关系\t512\n18.3.1 编译系统内部功能模块图\t512\n18.3.2 脚本文件的包含关系\t514\n18.3.3 从子项目中提取编译目标\t518\n18.3.4 生成编译规则\t519\n18.3.5 设置编译输出目录\t521\n18.3.6 生成最终的image文件\t522\n18.4 如何增加一个product\t523\n18.4.1 什么是一个product\t523\n18.4.2 如何增加一个product\t527\n18.5 如何增加一个项目\t528\n18.5.1 项目类别和项目路径\t529\n18.5.2 添加一个c项目\t530\n18.5.3 添加一个apk项目\t531\n18.6 apk编译过程\t533\n18.6.1 总体编译过程概述\t533\n18.6.2 生成r.java\t535\n18.6.3 编译aidl文件\t536\n18.6.4 包含java静态库\t536\n18.6.5 编译java源文件生成jar包\t538\n18.6.6 将jar包转换为dex文件\t539\n18.6.7 编译资源文件生成apk包\t540\n18.6.8 将dex文件添加到apk包中\t541\n18.6.9 添加jni所需的动态库文件\t541\n18.6.10 对apk文件进行签名\t543\n18.6.11 使用zipalign优化apk内部存储\t543\n18.7 framework的编译\t544\n18.7.1 总体编译过程\t544\n18.7.2 framework/core/ext三个jar文件的区别\t546\n18.8 编译android.jar\t547\n18.8.1 资源文件\t547\n18.8.2 aidl文件\t551\n18.8.3 java文件\t551\n18.9 编译adt插件\t553\n18.10 总结\t554\n第19章 编译自己的rom\t555\n19.1 嵌入式系统的内存地址空间\t555\n19.2 各种映像（image）文件的作用\t559\n19.3 编译nexus s（ns）的image文件\t562\n19.3.1 编译linux kernel\t562\n19.3.2 提取ns的私有驱动文件\t563\n19.3.3 编译system.img文件\t564\n19.3.4 创建ramdisk.img\t565\n19.3.5 创建boot.img文件\t566\n19.4 使用fastboot写入image文件\t566\n19.5 最后验证\t567\n19.5.1 解决触摸按键问题\t568\n19.5.2 解决音量和电源键\t568\n19.5.3 wifi问题\t570\n19.5.4 安装google mobile service（gms）\t571\n第5部分 硬件驱动篇\n第20章 基于ti omap处理器的 techshine 开发板介绍\t573\n20.1 techv-35xx开发板概述\t574\n20.2 交叉编译环境配置\t575\n20.3 x-loader编译\t578\n20.4 u-boot编译\t578\n20.5 techv-35xx linux驱动和内核配置及编译\t579\n20.5.1 touchscreen驱动配置\t579\n20.5.2 keyboard驱动配置\t580\n20.5.3 audio驱动配置\t581\n20.5.4 4mmc/sd驱动配置\t582\n20.5.5 nandflash驱动配置\t582\n20.5.6 lcd驱动配置\t583\n20.5.7 内核编译\t583\n20.6 techv-35xx android驱动编写\t584\n20.7 techv-35xx android开发环境建立\t589\n20.8 编译android donut\t590\n20.9 android根文件系统的制作\t591\n20.10 相关image文件的烧写\t591\n20.11 android 根文件系统安装\t593","pages":"595","images":{"small":"https://img3.doubanio.com/spic/s6937206.jpg","large":"https://img3.doubanio.com/lpic/s6937206.jpg","medium":"https://img3.doubanio.com/mpic/s6937206.jpg"},"alt":"https://book.douban.com/subject/6811238/","id":"6811238","publisher":"电子工业出版社","isbn10":"7121143984","isbn13":"9787121143984","title":"Android内核剖析","url":"https://api.douban.com/v2/book/6811238","alt_title":"","author_intro":"柯元旦，1981年生于陕西咸阳，2003年毕业于西安电子科技大学通信工程学院；2003～2006年，创立了一家设计公司，提供便携式媒体播放器解决方案，基于TI DSP芯片自主开发了一套操作系统，包括任务管理与调度、文件系统及GUI(图形用户接口)等：2006～2009年，就职于联想研究院，先后从事嵌入式系统设计以及互联网应用开发；2009年至今，从事Android应用程序开发和Framework内核研究，对Android内核有较深刻的理解。","summary":"由柯元旦编著的《Android内核剖析》详细分析了Android内核的内部机制，包括窗口管理系统、Activity管理系统、输入法框架、编译系统等，为Android内核定制及高级应用程序开发提供技术参考。\n    《Android内核剖析》适合于所有Android相关的工程师及产品经理，还可作为相关培训机构的教材。","price":"79.90元"}]
     */

    private int count;
    private int start;
    private int total;
    private List<BookSubjectsBeen> books;

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public int getStart() {
        return start;
    }

    public void setStart(int start) {
        this.start = start;
    }

    public int getTotal() {
        return total;
    }

    public void setTotal(int total) {
        this.total = total;
    }

    public List<BookSubjectsBeen> getBooks() {
        return books;
    }

    public void setBooks(List<BookSubjectsBeen> books) {
        this.books = books;
    }

}
